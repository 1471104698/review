# JVM

## 1、JVM 内存模型

```java
JVM：Java VM，即 Java 虚拟机，用来运行 class 文件，class 文件并不是直接跟操作系统打交道，而是在 操作系统 OS 和 class 文件之间架设了一层 JVM，通过 JVM 作为中间层，将 class 文件中方法的字节码指令通过内部的 Java 解释器翻译为跟 OS 相关的 CPU 指令

JRE：Java Runtime Environment，即 Java 运行环境，它包含了 JVM 和 基础类库，单单只能用来运行 class 文件，无法编写程序，因为它内部没有包含 编译器 和 调试器（debug）

JDK：Java Development Kit，即 Java 开发工具包，它包含了 
    JVM 和 基础类库（JRE）
    编译器、调试器、
    javac(将 java 文件 编译成 class 文件)、
    java（执行 class 文件）、
    javap（将 class 文件进行反编译，获取 class 文件内部信息）
        所以 JDK 可以编写程序，将代码转换为 class 文件，同时还可以运行程序。
```



```java
//1、程序计数器 PC：
是线程私有的，也是唯一一个不会发生 OOM 的区域，存储的是该线程下一条将要执行的字节码指令的位置（这里的位置不是内存地址，而是某个方法 code 属性字节码指令列表的 序号）
为什么需要 PC？
在单线程下，一个方法可以按照字节码指令按照顺序直接执行下去，此时这个 PC 没有什么作用
但是在多线程下，经常会发生线程上下文切换，Java 解释器不会去保存哪个线程执行到哪条字节码指令，所以 Java 解释器切换回来后，它本身是不知道当前执行到哪条字节码指令的，所以需要线程本身来记录
	注意：PC 记录只是记录字节码指令的偏移序号，但是没有记录的是哪个方法的字节码指令，所以这里应该还需要知道调用的是哪个方法，
	这里可以根据线程栈顶的栈帧来确定

//2、虚拟机栈 和 本地方法栈
它们都是线程私有的，虚拟机栈存储的是 Java 方法，本地方法栈存储的是 native 方法（非 Java 方法），HotSpot 将这两个栈合并为一个，因此实际上我们现在使用的 JVM 只有一个栈。
栈中存储的是栈帧，一个方法对应一个栈帧，栈顶的栈帧就是当前正在执行的方法
栈帧中包含：局部变量表、操作数栈、动态链接、方法返回地址
    1）局部变量表：存储方法中定义的局部变量，使用 slot 来表示，一个 slot 占用 32bit，一个变量占一个 slot，不满 32 bit 的变量也是一个 slot，如果是 long、double 这样的，那么就占两个连续的 slot
    2）操作数栈：存储当前字节码指令需要使用到的操作数，比如当前调用 a.h(1, 2)，那么会将 a 对象压入到操作数栈，再将调用的方法所需的参数压入到操作数栈，然后根据字节码指令执行方法。比如 return 时，会将需要返回的值压入到操作数栈，然后 return 操作数栈栈顶的数。
    3）动态链接：指向运行时常量池中 在类加载时期存储进去的常量池（constant pool）中该方法的引用， 在最上面我们讲了，PC 中只是存储了一个字节码偏移量，还需要知道方法的 code，因此这里的动态链接就是存储的常量池记录的方法 Method 对象，通过 Method 对象可以得到方法的 code，再根据 PC 内容确定字节码指令
    4）方法返回地址：这里的方法返回地址不是一个地址，它跟 PC 一样，不过是用在方法调用时，当方法 A 调用方法 B 时，由于使用的是同一个线程，而 PC 只有一个，所以此时的 PC 会去记录方法 B 的字节码指令位置，而 A 的就没了，所以需要记录方法 A 的字节码指令位置，这个方法返回地址记录的就是方法 A 调用方法 B 时，方法 A 的 PC 内容

本地方法栈中由于不是 Java 方法，所以只存在 --- 方法返回地址 ---

栈溢出 StackOverflowError：栈的空间是有限的，如果无限创建栈帧（递归）导致无法为新的栈帧分配空间，那么栈溢出
栈OOM：每创建一个线程都需要为它分配一个栈空间（1M 或者 10M），没有限制可以创建多少个线程，理论上是进程可以分配的最大空间，如果无法为新的线程分配空间，那么出现栈 OOM

//3、堆
堆是用来存储大部分对象，一个新对象的分配大部分都是在堆的伊甸区分配的。
堆分为新生代和老年代，新生代和老年代的比例为 1：2，新生代分为 1 个伊甸区和 2 个幸存区，新生代和两个幸存区的比例为 8：1：1
新生代使用的是复制算法，所以需要两个幸存者区，老年代使用的是标记-清除 和 标记-整理算法

如果在伊甸区无法为新的对象分配连续的内存，那么会出现 young GC，此时在 young GC 之前，会进行一次 空间分配担保 的计算：
	1）判断此次 young GC 在最坏的情况下，老年代是否能够容纳新生代的对象，
	2）如果不能，那么退一步，根据历次 young GC 晋升的新生代对象的大小判断老年代是否能够容纳，如果还是不能，那么直接触发 full GC。，full GC 会清理整个堆空间 。
young GC 会将新生代的对象转移到幸存区，将幸存区达到 GC age 阈值（阈值最大为 15，因为 mark 头部中记录 GC age 的为 4bit，最大为 1111，只能记录 15），或者满足动态计算晋升年龄阈值 的对象都转移到老年代。
注意， full GC 的触发看来是在 空间分配担保 策略实施后执行的，当然，还有一个大对象分配，如果老年代无法存储，那么也会触发 full GC；如果存在永久代，由于 永久代 和 老年代是绑定的，所以永久代满了也会触发老年代的 full GC
(这里讲一下，只有 CMS 才能单独处理 old 区，其他的 GC 回收器的 full GC 都必须新生代和老年代一起处理)
    
     Java 对象分配问题：
    	Java 对象不是都分配在堆上的，JDK 1.6 出现了 JIT 即时编译，JIT 有一个逃逸分析的技术。
     逃逸分析：
    	它会对方法中创建的对象进行分析，判断是否可能会被其他线程访问到，如果被外部指针引用，或者 return 了，那么就可能会被其他线程访问到，那么该对象存在逃逸
     栈上分配：
    	如果在方法中创建的对象不会逃逸，即它的生命周期仅仅局限于该方法（用完即毁），那么该对象可以在栈帧中进行分配，不需要分配到堆中（因为堆中的对象是所有线程共享的，而该对象只有调用该方法的当前线程才能访问到），从而减少对堆内存的占用，减少 GC。该对象在方法调用结束后随着栈帧的销毁而销毁。
     标量替换：
    	比如 A() 中创建了一个 User 对象，内部有两个 int 变量 x 和 y，而在方法中对该对象的访问仅仅是访问 x 和 y 变量，因此该 User 对象是能够打散的，不需要使用一段连续的内存来存储整个对象，直接在栈中不需要连续的内存空间存储两个 int 型变量来代替这个 User 对象。
    栈上分配不适合大对象和逃逸对象。
    有人说 HotSpot 没有真正的实现栈上分配，而是只有标量替换，如果只有标量替换的话那么就是只存在几个变量，这样的话如果对象存在方法调用那么就不能标量替换，只能在堆中进行分配，但是测试后发生创建的对象调用了方法后还是能够在栈上分配，而没有在堆中分配。（当然也有可能是把方法涉及到的变量全部创建出来，然后执行对应的字节码。）

 

//4、方法区
方法区存储的就是类的元数据
JDK 1.7 时还是永久代，JDK 1.8 变成了元空间
永久代跟 old 区是 GC 绑定的，所以其中一个出现问题都会触发 full GC（注意不是 old GC，old GC 只会出现在 CMS）；
元空间不在 JVM 内存中，它理论上可用空间等于物理内存
JDK 1.6 时，字符串常量池在方法区，JDK 1.7 时移动到堆中了
JDK 1.7 时，运行时常量池在方法区，JDK 1.8 时移动到堆中了
    （运行时常量池存储的就是 class 文件的常量池，跟方法的 code 属性相关的符号引用。JDK 1.7 的时候，class 常量池是存储在方法区的，JDK 1.8 是存储在堆中的，不过都是运行时常量池中，需要说明的一点是）
    方法区 OOM：通过 CGLIB 代理产生过多的 class 文件元数据堆满方法区。

//5、直接内存
直接内存不在 JVM 内存的范畴，这里只是扩展讲一下
    直接内存不受 JVM 的管理，它是堆外内存, 所谓的堆外内存是相对于 JVM 堆空间来说的，它仍然是属于用户态空间。
 	一般情况下完整的 IO 过程如下：
     Java 堆内存 -> 堆外内存 -> 内核态 socket 缓冲区 -> DMA -> 网卡1 -> 网卡2 -> DMA -> 内核态 socket 缓冲区 -> 堆外内存 -> Java 堆内存
    而使用堆外内存，由于不受到 JVM 管理，所以需要分配的时候不会导致 GC，同时能够减少 CPU 拷贝次数。
 
Java 直接内存的分配方式：
    1）ByteBuffer.DirectByteBuffer()：
        虽然直接内存不受 JVM 管理，但是 ByteBuffer 分配的直接内存实际上是间接受到 JVM 管理的，该对象在创建时会同时创建一个  Cleaner 对象，它继承了虚引用，在 GC 回收该 ByteBuffer 对象前，会将这个消息存储到对应的引用队列中，交给 ReferenceHandler 线程（JVM 启动时会启动该线程，优先级很高，通过 jstack 可以看到该线程）来处理，在该线程中，会调用 Cleaner 对象的 clean() 来释放堆外内存。
    2）unsafe：
        而如果是 unsafe 分配的直接内存，这就跟 C 分配内存一样，如果我们不手动释放，那么会导致内存泄漏
        
JVM 默认没有限制直接内存的大小，理论上等于一个进程所能够分配到物理内存。
使用一个死循环不断分配直接内存，使用 ByteBuffer 分配会频繁发生 GC，但电脑不会卡死；使用 unsafe 不会发生 GC，电脑卡死
这是因为 ByteBuffer 对象会 GC 回收，释放直接内存，而 unsafe 不会
当我们限制直接内存大小，那么都会发生 直接内存 OOM


//6、强软弱虚引用
1）强引用：默认的引用都是强引用
只要存在强引用，并且 GC roots 可达，那么就算 GC 后内存不足抛出 OOM 也不会回收这些对象。

2）软引用：使用 SoftReference 对象封装起来的对象，对该对象而言就是软引用，不过 SoftReference 对象本身是强引用
比如 SoftReference<User> soft = new SoftReference(new User()); 这个 User 对象就是被软引用所引用
通过 soft.get() 可以获取到 User 对象，如果 User 对象被回收了，那么 get() 返回 null.
如果 GC 后内存足够，那么不会回收软引用指向的对象，即不会回收 User 对象，如果内存不足，那么在抛出 OOM 前会回收 User 对象
不过 soft 对象本身是一个强引用

3）弱引用：使用 WeakReference 对象封装起来的对象
比如 WeakReference<User> weak = new WeakReference(new User()); 这个 User 对象就是被弱引用所引用
通过 weak.get() 可以获取到 User 对象，如果 User 对象被回收了，那么 get() 返回 null.
只要发生 GC 然后 User 对象被扫描到不存在强引用，只存在弱引用，那么会将 User 对象回收，即不管内存是否足够都会回收 User 对象

ThreadLocal 就是借助弱引用来解决部分内存泄漏问题

4）虚引用：使用 PhantomReference 对象封装起来的对象，它不用来缓存数据的，而是用来通知对象是否已经被 GC 回收了的，它需要跟 ReferenceQueue 引用队列绑定在一起使用，它的构造方法必须强制传入一个 ReferenceQueue
PhantomReference<User> pha = new PhantomReference(new User(), new ReferenceQueue<>()); 这个 User 对象就是被虚引用所引用
pha.get() 永远都是返回 null，因为它不是用来缓存对象的，当虚引用指向的对象被回收时，会将这个虚引用对象 pha 存储到与之绑定的引用队列中，然后我们可以从引用队列中获取这个虚引用对象来进行一些收尾工作

NIO 中的 ByteBuffer 分配的直接内存（堆外内存）就是通过虚引用来让 JVM 间接管理直接内存的释放的
在创建 DirectByteBuffer 对象，分配内存的时候，会同时创建一个 Cleaner 对象，该对象继承了 PhantomReference，当 DirectByteBuffer 对象被回收时，ReferenceHandler 线程会直接调用这个 Cleaner 对象的 clean() 来释放直接内存
（当然，这里没有涉及到引用队列，由于是 JDK 自己设计的 Cleaner，所以它可以不需要放入到引用队列中再处理，可以直接调用 clean() 进行处理，而如果是我们程序员来设计 Cleaner，那么 JVM 就会将这个 Cleaner 放入到引用队列中，然后在引用队列中调用 Cleaner 对象的 clean() 来释放直接内存）
        
        
```

*![image.png](https://pic.leetcode-cn.com/1608361799-uKIEHa-image.png)*



## 2、JVM GC

```java
GC 回收对象的判断：
1）引用计数法：一个对象被其他 x 个对象引用，那么它的引用计数为 x，当为 0 的时候可回收，缺点是无法解决循环引用的问题
2）可达性分析：从 GC roots 出发，递归标记存活对象

GC roots 包含 
1）栈帧中的局部变量
2）全局变量
3）本地方法中的变量
4）Class 对象中的静态变量
（反正只要是最开始可以确定存活的对象就都是 GC roots）

GC 算法：复制算法、标记清除算法、标记整理算法（标记的应该是可回收对象）
新生代使用的是复制算法，老年代一般情况下使用的是标记-清除算法，特殊情况下使用的是标记-整理算法

关于 GC 算法标记的对象：有说标记存活对象的，有说标记回收对象的，但是按照可达性分析来说，标记的应该是存活对象，对于可回收对象，它的 mark 的锁标志位会被设置为 11（具体怎么在 GC 过程中将标志位设置为 11 的，这个是底层细节，不得而知）

三色标记法：
GC 算法扫描过程中，使用的三色标记法
白色：未扫描或者可回收对象
灰色：扫描一半的对象
黑色：扫描完成的对象
最开始所有的对象都是白色对象，按照 GC roots 链递归扫描，最终在 GC roots 链上所有存活对象都是黑色的，没有被扫描到的对象，即可回收对象都是白色的，因此直接回收白色对象即可

GC 回收器：串行回收器、并行回收器、CMS、G1

CMS：
CMS 的出现是为了减少 串行和并行回收器的 STW 时间的
CMS 是只作用于 old 区的垃圾回收器，它只会回收 old 区，只有 CMS 才存在 old GC，其他都是 young GC 和 full GC
CMS 回收过程：
    1）初始标记：会进行 STW 暂停所有用户线程（进入安全点/安全区域），初步扫描所有 GC roots，标记存活对象，这里需要扫描新生代和老年代，为了确定新生代哪些对象存活从而确定老年代的存活情况，这里会使用 卡表 card table（卡表后面讲）
    2）并发标记：跟用户线程一起执行，递归扫描初始标记时标记的对象，使用的是三色标记法，同时它这里会使用增量更新的方式（具体是什么后面讲）
    3）预清理：STW，这里可以执行一次 young GC，回收新生代的部分对象，减少下面需要执行的重新标记扫描 GC roots，从而减少 STW 时间
    3）重新标记：STW，由于并发标记是跟用户线程一起执行的，用户线程可能会修改一些引用，所以这里需要重新扫描所有的 GC roots，但它会跳过黑色节点，只会扫描那些白色或者灰色节点，意味着大部分都可以跳过扫描
    4）并发清理：跟用户线程一起执行，回收可回收的老年代对象
    5）并发重置：重置 CMS 内部数据，为下一次 GC 做准备（具体重置哪些数据不太清楚）

G1：
G1 是为了在更少的 STW 时间内回收更多的对象。
它将整个堆空间划分为一个个大小相同的区域，称作 Region，这些 Region 不再固定属于新生代或者老年代，即跟 CMS 不一样，不需要规定新生代范围和老年代范围。同时，它还增加了一个专门用来存储 大对象的区域，即所有的类型为 E、S、O、H
    每个 Region 的类型不是固定的，现在是 S 区的 Region 之后可能是 O 区，反正是哪个区需要使用多一点的空间，就将多一点的 Region 分配给它，动态的，非常人性化。不过同一个 Region 只能存储一个类型的区的对象，不能 S 区 和 O 区对象混合存储。
G1 回收过程：
    1）初始标记：跟 CMS 差不多，不过这个阶段一般同时也会执行 young GC，可以说占用的是 young GC 的时间（不过个人感觉怪怪的，因为 mixed GC 本来就是会回收 young 的）
    2）并发标记：跟 CMS 差不多，区别在于它不会使用增量更新，而是使用快照的方式记录被删除的引用
    3）重新标记：根据并发标记的快照恢复引用
    4）筛选回收：根据每个 Region 中的存活对象等信息，统计所有 Region 的回收价值，根据回收价值进行排序，然后按照用户希望的停顿时间，回收所有的新生代 Region 和 部分老年代 Region，它会将需要回收的 Region 中的存活对象复制到 空的 Region 中，然后回收掉整个 Region
    
    CMS 有 young GC、old GC（只回收老年代）、full GC（回收新生代 + 老年代）
    G1 有 young GC、mixed GC（回收新生代 Region + 部分老年代 Region）、full GC

浮动垃圾问题：
在 GC 过程中，如果用户将引用修改，将黑色节点从 GC roots 链上断开，变成了可回收对象，但是由于它已经扫描过了，所以它在此次 GC 中无法被回收，只能留到下一次 GC 回收，这些对象称作浮动垃圾（CMS 和 G1 都无法处理）

对象消失问题:
在 GC 过程中，用户修改引用，将一个 GC roots 链上的白色对象从 GC roots 链上断开，然后让它跟别的黑色节点进行连接，这样的话，由于黑色节点已经扫描过了，所以它不会再去扫描，导致在回收的时候对象是白色的，被回收


对象消失问题的解决方法 --- 增量更新 和 快照：
    1）CMS 在并发标记时，使用的是增量更新，当用户线程修改引用，在黑色节点上插入一个白色节点时，那么这个黑色节点就需要修改为灰色，重新进行扫描，这样可以避免对象消失
    2）G1 在并发标记时，使用的是快照，它只关注引用的删除，它会将删除的引用关系存储到一个队列中，然后在重新标记阶段它不会去扫描所有的 GC roots，而是从这个队列中的引用关系出发进行扫描，避免对象消失
G1 使用了快照，它只关注引用的删除，所以在重新标记阶段不会扫描所有的 GC roots，所以比 CMS 要更快，但是一些被删除的引用的对象应该是需要会回收的，但是它被重新扫描后会被标记为黑色节点，因此导致 G1 会比 CMS 出现更多的浮动垃圾

并发标记过程中用户创建新对象的问题：
	1）CMS 使用增量更新，所以新创建的白色对象无论是跟 GC roots 上的白色、灰色、黑色哪一个节点进行连接，都可以扫描到，不会导致新的对象被回收的问题
	2）G1 它只关注删除的引用，而新对象它的引用关系它并不会去记录，所以如果新对象跟黑色节点建立连接，G1 是不知情的，那么它应该会被回收，但是肯定不可能让它回收，G1 底层使用了两个 map 来记录新对象的引用，具体看 [G1 中用户创建新对象的解决方法](https://www.cnblogs.com/thisiswhy/p/12388638.html)			，我也不太清楚，反正是有进行处理就对了

CMS 的并发失败问题：
在 CMS 进行 old GC 的时候，用户线程如果需要分配内存，而内存不足，那么就会导致并发失败，从而升级为 full GC，由于 CMS 只能进行 old GC，所以它会退化为 串行回收器，效率降低
解决方法：预留内存，不要在快满的时候才触发 GC

卡表 和 Remember Set（RSet）：
    1）卡表 card table：为了避免在 young GC 时扫描整个老年代，将老年代分为大小相同的多个区域，默认是 512B，每个区域称作卡页，而卡表上则是记录了每个卡页对 新生代的引用情况，卡表上的每个卡表项映射一个卡页（类似分页机制的页表），当对应卡页上的老年代对象存在对新生代对象的引用时，那么卡表项值为 1，表示对应的卡页为脏页。
    在 young GC 时想知道新生代哪些是被老年代对象引用的，直接扫描卡表，然后找到卡表项为 1 的，扫描这些卡表项对应的卡页中的老年代即可。这样可以避免扫描那些卡表项为 0 的区域，从而避免扫描整个老年代。由于老年代对新生代对象的引用是很少的，所以相当于只需要扫描老年代的一点区域而已。

    2）Remember Set：由于 G1 将整个堆空间划分为 Region，淡化了分区的概念，在 GC 的时候需要知道 Region 中的对象哪些是被其他 Region 引用的，因此 CMS 中一个简单的卡表在这里并不适用，所以出现了 RSet，它是对卡表的扩展， 原本是一个老年代对应一个卡表，现在是每个 Region 对应一个卡表，记录着其他 Region 对当前 Region 的引用情况，这种一个 Region 对应一个卡表的 方案称作 RSet。在回收一个 Region 的时候不需要扫描所有的 Region，只需要扫描 RSet 上哪些 Region 存在对该 Region 的引用，然后去扫描这些 Region 即可。
    它将每个 Region 划分为大小相同的多个区域，大小为 512B（跟 CMS 的老年代划分一样，就是类似将每个 Region 当作老年代那样），然后给每个 Region 都分配一个卡表，这个卡表实际上就是一个 HashTable<key, byte[]> 的类型，key 存储的是其他的 Region 的地址，byte[] 是 key 对应的 Region 的卡页，byte[0] 表示是第一个卡页，byte[1] 表示是第二个卡页。
    它用来记录当前 Region 中被其他 Region 的哪些 card 给引用了，这样在回收该 Region 的时候，只需要扫描它的 RSet，然后只需要扫描那些引用了它的其他 Region 的 card，确定当前 Region 的存活对象即可
    需要注意的是，它只是记录了其他 Region 的哪些 card 引用了当前 Region，而没有具体到引用了当前 Region 的哪个 card。如果要记录的话，那么就需要三层架构了，而不是单单 HashTable 两层架构
```

卡表 ：

<img src="https://user-gold-cdn.xitu.io/2020/7/3/1731052eb999f1a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:40%;" />

RSet：

<img src="https://pic.leetcode-cn.com/1604937577-UMiHDP-image.png" style="zoom:50%;" />





## 3、JVM 方法重载和方法重写

```java
方法重载：同一个方法名，不同的方法参数（方法名相同，方法参数、个数不同），方法具有唯一性
方法重写：同一个方法名 和 相同的方法参数，只能出现在父子类之间，方法不具有唯一性

方法重载：
    在编译期间编译器就可以确定的了，比如 A 类有 h(), h(int i), h(String str), h(int i, String str) 四个同名方法
    当我们执行：
        A a = new A();
        a.h(1);
    编译器在编译期间就可以根据方法名 + 参数个数 + 参数类型确定调用的是 h(int i)

方法重写：
    方法重写发生在父子类之间，能够被子类重写的方法，叫做虚方法，除 private、final、static、构造方法外，剩下的都是虚方法
    编译器在编译期间只能根据引用指针的类型确定方法重载，但无法确定真正调用的是哪个对象的方法，
    因为在编译期间编译器无法确定引用指针引用的是哪个对象
    比如 
        class B{
            public void h(){
                System.out.println("B");
            }
            public void h(int i){
                System.out.println("B i");
            }
        }
        class A extends B{
            @Override
            public void h(){
                System.out.println("A");
            }
        }
    当我们执行 
        B b = new A();
        b.h();
    编译器只能确定调用的是 B 的 h()，而不是 B 的 h(int i)
    但是它此时是不会去获取 b 指向的对象类型的，即不知道调用的是 A 的 h() 还是 B 的 h()，因为编译器不确定
    有的人可能会说为什么不确定？引用的对象类型不是在 = 后面了吗？
    这是因为可能有时候存在如下情况：
    ①、
        B b = new B();
        b = new A();
        b = new B();
        b = new A();
    ②、
        int i = new Scanner(System.in).nextInt();
        B b;
        if(i < 0){
            b = new B();
        }else{
            b = new A();
        }
        b.h();
    对于第一种情况，编译器是可以根据上下文确定的，不过有点麻烦，对于第二种情况，编译器是无法进行确定，具有不确定性
    所以编译器干脆就不去确定了，调用的是哪个对象的方法就留到运行期间的解析阶段，根据操作数栈的栈中对象来得知真正的对象类型
```



## 4、JVM 类加载机制

```java
类加载阶段分为：加载-验证-准备-解析-初始化
其中 JVM 规定了 解析阶段不一定必须在 类加载的时候执行，可以留到运行期执行，也就是说在方法第一次调用的时候进行解析

1、加载：JVM 使用的是 OOP-Klass 体系
	将 class 文件中的信息转换为方法区的数据结构，一个 class 文件表示一个类，在方法区创建的就是 Klass 对象。
	Klass 会记录类的元数据，比如 父类、接口、方法 和 字段。
		方法对应的结构体为 Method，内部包含了方法名、访问修饰符、方法参数、方法的 Code 属性，如果是虚方法，那么会包含在 vtable 中的索引位置
		字段对应的结构体为 Field，内部包含了字段名、访问修饰符、字段偏移量[offset_start, offset_end]，
        这个偏移量是表示相对于 OOP 对象体来说的，这里可以看出每个类的每个字段它的偏移位置都是固定了的，
        因此可以直接通过偏移量来定位到字段，获取字段值，这也是 CAS 中使用 unsafe 的实现前提
	同时这个阶段还会在堆中创建 Class 对象，Klass 对象和 Class 对象是双向指向的，
        这也就是我们常说的是 Class 对象是反射的入口，正是因为可以通过 Class 对象访问类的元数据

2、验证：当加载完成了，再来验证字节码是否存在错误，比如 类是否继承了 final 类之类的
		因为如果是正常的通过编译器编译，那么肯定是没有问题的，但是 class 文件的获取不一定是通过编译器编译，可能是从网上下载的，这样的话 class 文件可能存在非法信息
		
3、准备：为静态变量赋初始值
       	这里实际上就是分配内存空间，同时由于分配的内存空间上可能是其他进程使用过的，数据没有清零，所以操作系统在这里会把分配到的内存数据清零，将所有 bit 都置为 0（操作系统好像不会回收内存的时候就清零，而是在需要使用的时候再清零）
            (注意，这里的静态变量只是变量，而不是 = 右边的值，所有的对象都是存储在堆中的，所以 GC roots 才包括 static)
		比如 int 类型的初始值为 0，是因为分配内存后上面的值都是 0，
		而引用类型则是 null，同样的分配的内存上面不存在任何有效的地址，是空指针
		对于 final static，这种不会赋初值，而是直接将程序员定义的值赋值给它
		在 JDK 7 的时候，static 变量从方法区移到了 Class 对象中，因此这里是在 Class 对象中分配内存
            (静态变量不在这里直接赋值的原因是可能后续初始化阶段静态代码块可能会修改对应的值，所以这里如果直接赋值的话那么会导致无效赋值)

4、解析
所谓的解析，就是将方法的 Code 属性中的 putstatic #15、invokevirtual #11 等字节码指令 和 运行时常量池中 constant pool 中的 Methodref 和 Fieldref 等代表符号引用的结构体替换为真正的指向方法区 Klass 对象中的 Method 和 Filed 结构体

如何解析？
    Constant pool:
       #1 = Methodref          #7.#37         // java/lang/Object."<init>":()V
       #2 = Fieldref           #3.#38         // cur/A.a:I
       #3 = Class              #39            // cur/A
       #4 = Methodref          #3.#37         // cur/A."<init>":()V
       #5 = Methodref          #3.#40         // cur/A.h:()V
       #6 = Fieldref           #3.#41         // cur/A.b:I
       
  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #3                  // class cur/A
         3: dup
         4: invokespecial #4                  // Method "<init>":()V
         7: astore_1
         8: aload_1
         9: invokevirtual #5                  // Method h:()V
        12: return

首先我们可以看出在 main() 的 Code 属性的字节码指令中，存在 invokevirtual #5 这种，invokevirtual 表示调用都是虚方法，#5 表示它调用的方法的信息在常量池 #5 的位置，算是一个符号引用，因为没有真正的具体信息。
我们看上面 Constant pool 中 #5 对应的是一个 Methodref 结构体，它包含了 方法所属的类、访问修饰符、方法名、方法参数个数
	Methodref 结构体如下：
    CONSTANT_Methodref_info {
    	//字节码指令后面跟着的 #5， 这个 5 就是这个 tag
        u1 tag;						
        //指向常量池的其他数据结构，表示方法所属的类，比如上面的 #3 Class 和 #5 后面的 #3.#40，表示之间的关联
        u2 class_index;             
        //指向常量池的其他数据结构，存储方法的方法名 和 方法描述符，方法描述符存储着方法的 参数个数 以及 方法的访问修饰符 
        u2 name_and_type_index;     
    }

    在运行时期，当 JVM 解释器执行到 invokevirtual #5 时，发现还没有解析，仍然是符号引用，所以无法获取 #5 对应的 Code 属性，所以会先进行解析。
    根据 #5 找到 Methodref 结构体，然后获取方法的信息，由于这里是 invokevirtual，表示是一个虚方法，所以需要知道真正的调用对象，那么会从操作数栈中获取到调用的对象（在执行 invokevirtual 指令前，肯定会先执行其他的字节码指令，将方法调用对象 和 方法所需的参数压入到操作数栈中），然后根据这个对象从 OOP 对象头中的 Klass 指针进入到方法区，然后根据方法信息扫描虚方法表，定位到调用方法的 Method 对象，最终返回，将 Constant pool 中的 Methodref 对象替换为该 Method 对象指针，将 invokevirtual 替换为 invokevirtual_quick 表示已经解析过了，下次调用该方法的字节码指令无需再次解析，将 #5 替换为 Method 所在的 vtable 的下标 和 方法参数个数，完成解析。
    最后开一个栈帧，将栈帧中的动态链接指向常量池中的 Mehtod 对象，然后根据 Method 对象获取内部的 Code 属性，调用字节码指令，执行该方法。


所谓的运行时常量池存在字面量是什么意思？
我们都知道，运行时常量池存储的是 常量池（里面一堆符号引用 Methodref、Fieldref），那么字面量是什么？
字面量就是我们直接定义的:
	String a = "abc";
	long l = 2L;
以上这种就是字面量，它同样是以符号引用存储在常量池中的，比如
    Constant pool:
       #1 = Methodref          #8.#31         // java/lang/Object."<init>":()V
       #2 = Long               2l		
       #4 = Fieldref           #7.#32         // cur/A.l:J
       #5 = String             #33            // abc
       。。。
       #33 = Utf8               abc
	上面的 #2 Long 就是 l 的符号引用， #5 String 就是 a 的符号引用，它的数据结构不是 Fieldref，而是 Long 和 String
	不过 #5 String 相当于只是一个 index 索引，指向的 #33 Utf8 才是真正的字符串内容，在解析阶段会通过 ldc 指令解析为堆中的对象。


 
5、初始化：执行静态代码块，同时为 static 变量赋值，这里的值是程序员定义的值

类加载阶段完成
```

