# 网络模型



## 1、七层网络模型

1）应用层（HTTP、FTP、SMTP（简单邮件传输协议 Simple Mail Transfer Protocl）、DNS）
2）表示层：SSL/TCL
3）会话层
4）传输层：TCP、UDP
5）网络层：IP、ICMP（跟 TCP、UDP 同级，都是被 IP 封装，但是属于网络层协议）、ARP（工作在数据链路层，但是属于网络层协议）
6）数据链路层：MTU、VPN
7）物理层：



## 2、DNS、ARP、ping

### 1、DNS

> #### DNS 是什么？

DNS 是域名解析，将域名解析为 IP 地址

**DNS 协议是应用层协议**



> ####  域名是什么？

比如 www.baidu.com：
1）com 是顶级域名，这种是固定的，比如 com 表示 company， 是商业用的
2）baidu 是权威域名，是用户自己注册的，比如百度创始人自己注册为 baidu
3）www 是主机名，在 baidu.com 下可以有很多主机名不同的子域名
实际上真正的域名应该是 www.baidu.com. ，即最后有一个根域名 '.'，不过所有的域名后面都有，所以直接省略了根域名



> ####  DNS 解析过程：

1）按照 浏览器缓存、操作系统缓存、hosts 文件的顺序进行访问，如果存在对应域名映射，那么直接使用（这也就是如果计算机的域名映射被黑客修改了，那么每次访问都会跳转到恶意网站上）
2）浏览器调用操作系统的一个函数，通过网卡给本地 DNS 服务器（我们网络配置的默认 DNS 服务器）发送一个 DNS 请求，本地 DNS 服务器收到后，查看自己的 DNS 缓存，如果存在的话那么直接返回。
3）本地 DNS 服务器内部会存储 根域名服务器（.），将 DNS 请求发送给 根域名服务器
	（这里讲下域名服务器的种类：根域名服务器（.）、顶级域名服务器（com）、权威域名服务器（baidu.com））
4）根域名服务器不会直接负责域名解析，它存储 顶级域名服务器的对应的 ip 地址，因此它会将 www.baidu.com 对应的顶级域名服务器（com）的 ip 地址告知本地 DNS 服务器
5）本地 DNS 服务器拿着这个 ip 地址去访问顶级域名服务器（com），顶级域名服务器维护顶级域名下的权威域名（baidu.com），因此它会将 www.baidu.com 中的权威域名服务器（baidu.com）的 ip 地址告知 本地 DNS 服务器
6）本地 DNS 服务器拿着这个 ip 地址去访问权威域名服务器（baidu.com），权威域名服务器维护权威域名下的子域名（www.baidu.com），因此它会将 www.baidu.com 的 ip 地址告知 本地 DNS 服务器。
7）本地 DNS 服务器将 ip 地址存储下来，然后返回给浏览器，浏览器收到后同时也会缓存下来，然后发起 TCP 连接请求



全世界存在 13组 根域名服务器，但是不是只有 13 台根域名服务器，因为它们存在从根域名服务器（镜像域名服务器），分担 DNS 查询请求



> ####  DNS 解析方式：递归 和 迭代



> ####  DNS 使用的传输层协议：

1）UDP：在默认情况下 DNS 使用 UDP 协议，因为不需要建立握手，也不需要保证什么可靠性，省去了 3 次 TCP 握手的时间，因为一次 DNS 解析需要多次请求，如果频繁的 TCP 连接效率非常低
2）TCP
	①、区域传送：DNS 服务器采用集群的方式，存在主从域名服务器，从域名服务器启动时需要跟主域名服务器同步数据，这时候就需要使用可靠的 TCP 来同步数据
	②、数据大于 512B：DNS 的 UDP 最多只能传输 512B 数据，一旦超过 512B，而 UDP 包又不能分割，所以只能使用 TCP。

DNS 劫持：攻击的方式之一是 黑客攻击了计算机的路由器，将本地 DNS 域名服务器设置为自己搭建的 DNS 域名服务器，无论什么域名都返回自己的恶意网站的 ip 地址，这样用户就会一直访问这个恶意网站



### 2、ARP

ARP 协议：使用 IP 地址到 MAC 地址的映射

**ARP 协议是网络层协议**



> ####  交换机和路由器：

同个网段的不同主机连接的是交换机（不一定是同一台，可能是不同的交换机，不过这些交换机之间互相连接），通过交换机来进行通信，而交换机是二层网络（数据链路层），只识别 MAC 地址。
由于交换机连接的是同个网段的主机，所以不同网段的主机间的通信不能通过交换机，需要转发给网关进行路由，找到目的主机所在的网段，然后交给该网段的交换机，转发给目的主机。即交换机是用来通信，路由器是用来寻路的。
路由器（网关）本身存在多个接口，连接了多个网段，因此可以说路由器是多个网段的，可以跟不同网段的主机进行通信

我们需要记住，在路由转发的过程中，会改变的只有目的 MAC、源 MAC，而 源 IP 和 目的 IP 是不会发生改变的，比如主机 A 和 主机 B 路径上存在 3 个路由器，路由器1、路由器2、路由器3，那么在路由转发的过程中，路由器1 将消息路由转发给路由器2 时，数据链路层的消息如下：源 IP（主机 A）、目的 IP（主机 B）、源 MAC（路由器1）、目的 MAC（路由器2），后面的传输也是如此
反正就是根据 IP 地址来确定目的路径，而 MAC 是在路径上不断进行中转的
	（IP 比如我到医院，而 MAC 这段路径不断转换的路程，比如广州南->车陂南，车陂南->杨箕，杨箕->农讲所，最终步行到达目的地）
路由器进行下一跳的数据传输也是需要经过数据链路层到达下一个路由器的，所以需要 MAC 地址，而不是凭空发送。



> #### 同网段 ARP 解析过程：

​    1）主机 A 将 源 IP（主机 A）、目的 IP（主机 B）、源 MAC（主机 A） 封装为一个 ARP 请求报文（目的 MAC 全是 0），调用数据链路层接口，交给数据链路层
​    2）数据链路层将 ARP 请求报文封装为数据帧，MAC 报文头部中  源 MAC （主机 A），目的 MAC（全 F，表示广播地址），发送到交换机
​    	（一个数据帧包含源 MAC 和 目的 MAC，内部的 ARP 报文也包含源 MAC 和 目的 MAC，
​    			不过 ARP 报文的目的 MAC 是全 0，数据帧的目的 MAC 是全 F
​    			相当于 ARP 报文实际上是替代了原来数据帧中 IP 报文的位置，所以才说 ARP 是网络层协议）
​    3）交换机收到数据帧后，查找自己的 MAC 表，如果匹配了 MAC 表，那么根据对应的端口发送出去，如果没有匹配，那么进行广播（这里由于 目的 MAC 全是 F，是广播地址，所以会直接进行广播）
​    4）其他主机收到 ARP 包后，如果上面的 IP 地址不是自己，那么舍弃；如果是自己，那么将主机 A 的 IP 和 MAC 进行映射缓存到 ARP 表中，再将 源 IP（主机 B）、目的 IP（主机 A）、源 MAC（主机 B）、目的 MAC（主机 A）封装为一个 ARP 响应报文，通过交换机单播给主机 A
​    5）主机 A 收到后，将 MAC 地址缓存起来，完成 ARP 解析



> #### 跨网段 ARP 解析（ARP 代理）：

​    由于路由器会隔绝两个不同网段之间的广播，所以如果主机 A 和 主机 B 不在同一个网段，那么主机 A 是收不到主机 B 的 ARP 响应报文的。
​    1）所以主机 A 需要跟主机 B 通信，但是却不知道主机 B 的 MAC 地址时，主机 A 通过子网掩码发现主机 B IP 不在同个网段中，那么就需要通过网关（路由器）来发送，如果主机 A 只知道网关 A 的 IP 地址（我们网络配置的默认网关 IP），那么需要进行一次同网段的 ARP 解析（ARP 请求报文中目的 IP 为网关 A 的 IP），然后获取到网关 A 的 MAC 地址，主机 A 缓存网关 A 的 MAC 地址。
​    2）此时的 ARP 解析实际上已经完成了。

这里讲下主机 A 缓存了网关 A 的 MAC 地址后，如何跟主机 B 进行通信：
    1）主机 A 发送给主机 B 的消息是通过交换机先发送网关 A 的，此时消息信息为 源 IP（主机 A）、目的 IP（主机 B）、源 MAC（主机 A）、目的 MAC（网关 A）
    2）网关 A 收到消息后，如果网关 A 和 主机 B 在同个网段（上面也说了路由器是多网段的），那么一次同网段 ARP 解析获取主机 B 的地址，然后网关 A 再将消息发送给数据链路层（交换机）发送给主机 B
    3）如果 网关 A 和 主机 B 不在同个网段，中间需要经过多个路由器，那么网关会根据 目的 IP 找到下一跳的网关 B 地址，如果不存在网关 B 的 MAC，那么进行一次 ARP 解析，获取网关 B 的 MAC 地址，然后交给数据链路层，数据链路层封装的数据帧头部为 源 MAC（网关 A）、目的 MAC（网关 B），然后通过交换机发送给网关 B。网关 B 收到后，按照同样的方法，直接路由转发到主机 B
    4）主机 B 收到消息后，如果要给主机 A 发送消息，那么也是按照这种方法往回发



> #### MAC 头部 和  ARP 报文

下面是 ARP 和 数据帧头部，即一个数据帧包含源 MAC 和 目的 MAC，内部的 ARP 报文也包含源 MAC 和 目的 MAC

不过 ARP 报文的目的 MAC 是全 0，数据帧的目的 MAC 是全 F

![img](https://pic1.zhimg.com/v2-96c46b4413e5a6c3d0a4324ddc92aeac_b.jpg)





> #### ARP 欺骗攻击：

这种攻击都是存在 “中间人”
    1）假设网络中存在 3 台主机 P1、P2、P3， P1 要跟 P2 进行通信，但是不知道 MAC 地址，所以会发送 ARP 广播
    2）正常情况下 P3 收到 ARP 请求报文后是会直接舍弃的，但是它作为中间人，会将自己的 MAC 地址作为 P2 的 MAC 地址，封装成 ARP 响应报文单播给 P1
    3）P2 收到后发现是自己的 ip，同样进行单播给 P1
    4）此时 P1 就会收到 P2 和 P3 的 ARP 响应报文，它不知道选择哪一个，但是它有一个决策，相信后来的 ARP 响应报文
    5）正是由于这个决策，所以 P3 为了保证自己能够被 P1 选中，所以它会不断的发送 ARP 响应报文，以此来覆盖 P2 的 ARP 响应报文
    6）最终 P1 选择了 P3，那么 P1 给 P2 发送的消息都会发送到 P3，这样 P3 就持有通信数据了，如果 P2 要给 P1 发送消息，那么 P3 可以使用相同的方法



### 3、PING

ping 使用的是 ICMP 协议，用来判断某个 IP 是否可达

**ICMP 协议是网络层协议**

端口是传输层协议，是 TCP、UDP 协议需要使用的，而 Ping 只需要使用到 IP，它不会涉及到端口，因此 Ping 只能 ping ip，不能用来判断某个 IP 的某个端口是否能够访问



主机 A 对 主机 B 发起 ping www.baidu.com 时：

- Ping 的是域名，因此会先进行 DNS 域名解析获取 IP
- 将源 IP、目的 IP 封装成一个 ICMP 报文，发送到数据链路层
- 数据链路层数据传输需要  MAC 地址，因此会使用 ARP 解析获取 目的 IP 的 MAC 地址（如果是跨网段那么是路由器的 MAC 地址），将源 MAC、目的 MAC 作为 MAC 头部组装到 ICMP 报文上，然后进行路由转发
- 如果在特定时间内（MSL / TTL）到达目的主机，那么目的主机会返回一个 ICMP 回应报文，此时 主机 A 收到后即 Ping 成功



TTL：IP 头部会存在一个 TTL 字段，表示路由转发过程中最大的能够经过的路由器的个数，每经过一个路由器那么该值 -1，为 0 时报文丢弃。

​		  TTL 的作用是为了避免一些报文在网络中一直到达不了目的主机而不断转发阻塞网络







## 3、浏览器访问 url 的整个过程

url 的大致过程：
1）输入 url
2）判断缓存
3）DNS 解析
4）ARP 解析
5）TCP 握手 / SSL 握手，发送 HTTP 请求
6）服务器响应请求
7）判断是否需要 cache
8）html 解析、渲染，如果是 HTTP 1.1，那么需要再发起请求获取 css、js、图片等资源，如果 HTTP 2.0，那么服务器会进行推送



> ####  1、浏览器输入 www.baidu.com



> ####  2、判断缓存

首先获取浏览器缓存，判断是否有 URL 请求的资源
如果存在，那么根据 expires 和 cache-control 判断缓存是否过期，如果没过期，那么继续使用，如果已经过期，那么携带 If-Modified-Since 请求头字段，向服务器发送请求，服务器收到请求后，对比  If-Modified-Since 的时间以及资源更新的最新时间，如果最新时间较新，表示资源发生修改，那么响应最新资源以及 200 状态码，如果资源没有发生修改，那么响应 3.4
如果缓存不存在，那么需要向服务器发起 GET 请求，服务器响应资源以及 200 状态码



**Last-Modified 和  If-Modified-Since 的作用和关系：**

服务器在响应结果的时候会返回一个 Last-Modified 字段，表示资源最新修改的时间，当浏览器发现缓存过期并且存在 Last-Modified 字段时，那么浏览器会将 Last-Modified 的值作为 If-Modified-Since 字段值，然后将 If-Modified-Since 字段发送给服务器，让服务器进行资源是否更新的判断



> #### 3、DNS 解析

**DNS 协议是应用层的**

DNS 解析是通过域名得到 IP 地址



域名 `www.baidu.com`  的域名全称是 `www.baidu.com. `，域名最后有一个 `.  `  表示根域名，因为所有域名都存在根域名，所以平时都省略了根域名

域名分层：

1）顶级域名：com

2）权威域名：baidu.com



请求访问的是域名，需要进行域名解析得到 IP 地址，浏览器会先按照**浏览器缓存、操作系统缓存、hosts 文件**的顺序尝试获取 IP 地址，都没有那么向本地 DNS 服务器发起 DNS 解析请求：
1）本地 DNS 服务器收到请求后，查看自己的缓存，如果有就返回，没有那么向根域名服务器（.）发起 DNS 请求
2）根域名服务器不负责域名解析，它维护所有顶级域名服务器的 ip 地址，它会将 `com` 顶级域名服务器的 ip 地址发送给本地 DNS 服务器
3）本地 DNS 服务器拿到 `com`顶级域名服务器的 ip 地址，向它发起 DNS 请求
4）`com`顶级域名服务器维护 `com` 所有子域名的权威域名服务器的 ip 地址，它会将 `baidu.com` 权威域名服务器的 ip 地址发送给本地 DNS 服务器
5）本地 DNS 服务器拿到 `baidu.com` 权威域名服务器的 ip 地址，向它发起 DNS 请求
6）`baidu.com` 权威域名服务器维护 `baidu.com` 所有子域名的 ip 地址，它会将 `www.baidu.com` 的 ip 地址返回给本地 DNS 服务器
7）本地 DNS 服务器将 ip 地址存储到缓存，同时返回给浏览器，完成 DNS 解析



DNS 解析涉及到**递归和迭代**两种方式



**DNS 默认情况下是使用 UDP**，因为如果使用 TCP 的话每次请求都需要三次握手 + 四次挥手，这样的话需要 3.5 个 RTT，物理距离越长耗费的时间越长，效率低。



DNS 使用 TCP 的情况：

1、DNS 的 UDP 限制最大为 512B，如果超过 512B 需要使用 TCP
2、区域传送（从 DNS 服务器 复制 主 DNS 服务器的数据，为了保证数据的可靠性，需要使用 TCP1）

（DNS 好像为了防止伪造 DNS 域名服务器的应答，跟 HTTPS 一样有个证书链，加上证书链的 DNS 超过几千字节）



> ####  4、ARP 解析

ARP 协议：使用 IP 地址到 MAC 地址的映射

**ARP 协议是网络层的**

DNS 解析获取 IP 地址后，如果没有对应的 MAC 地址，那么需要 ARP 解析



**交换机和路由器：**
同个网段的不同主机连接的是交换机（**同个网段可能存在多个交换机，这些交换机相互连接**），通过交换机来进行通信，而交换机是二层网络（数据链路层），只识别 MAC 地址。
交换机连接的是同个网段的主机，**不同网段的主机间的通信只能通过网关进行路由**，路由器找到目的主机所在的网段，然后交给该网段的交换机，转发给目的主机。即**交换机是用来通信，路由器是用来寻路的**。
路由器（网关）本身存在多个接口，连接了多个网段，因此可以说**路由器是多个网段的，可以跟不同网段的主机进行通信**

我们需要记住，**在路由转发的过程中，会改变的只有目的 MAC、源 MAC，而 源 IP 和 目的 IP 是不会发生改变的**，比如主机 A 和 主机 B 路径上存在 3 个路由器，路由器1、路由器2、路由器3，那么在路由转发的过程中，有以下传输过程：

1）、路由器1 传输给路由器2 时，数据链路层消息内容如下：源 IP（主机 A）、目的 IP（主机 B）、源 MAC（路由器1）、目的 MAC（路由器2）

2）、路由器2 传输给路由器3 时，数据链路层消息内容如下：源 IP（主机 A）、目的 IP（主机 B）、源 MAC（路由器2）、目的 MAC（路由器3）

简单讲：**IP 地址用来确定目的路径，MAC 用来在路径上不断进行中转**
	（IP 比如我到医院，而 MAC 这段路径不断转换的路程，比如广州南->车陂南，车陂南->杨箕，杨箕->农讲所，最终步行到达目的地）
**路由器进行下一跳的数据传输也是需要经过数据链路层到达下一个路由器的，所以需要 MAC 地址，一般情况下（非 wifi）数据不是凭空在空气中直接传输的，是通过物理层传输的**。



**同网段 ARP 解析过程：**
    1）主机 A 将 自己的 IP 和 目的 IP 都跟子网掩码进行**按位与**操作，得到的结果相同，在同个网段，那么将 源 IP（主机 A）、目的 IP（主机 B）、源 MAC（主机 A） 封装为 ARP 请求报文（目的 MAC 全是 0），调用数据链路层接口
    2）添加 MAC 头部，封装为数据帧，MAC 报文头部中  源 MAC （主机 A），目的 MAC（全 F，表示广播地址），发送到数据链路层设备（交换机

```
一个数据帧分为两部分：MAC 头部 和 ARP 请求报文。
MAC 头部包含源 MAC 和 目的 MAC，ARP 请求报文也包含源 MAC 和 目的 MAC。

MAC 头部的目的 MAC 是全 F，用于 ARP 广播
ARP 请求报文的目的 MAC 是全 0
```

​    3）交换机收到数据帧后，由于 MAC 头部的 目的 MAC 全是 F，是广播地址，所以交换机会进行广播

```
一般情况下，交换机收到数据帧后，查找自己的 MAC 表，如果匹配了 MAC 表，那么根据对应的端口发送出去，如果没有匹配，那么进行广播
```

​    4）其他主机收到 ARP 包后，如果上面的 IP 地址不是自己，那么舍弃；如果是自己，那么将主机 A 的 IP 和 MAC 进行映射缓存到 ARP 表中，再将 源 IP（主机 B）、目的 IP（主机 A）、源 MAC（主机 B）、目的 MAC（主机 A）封装为 ARP 响应报文，通过交换机单播给主机 A
​    5）主机 A 收到后，将 MAC 地址缓存起来，完成 ARP 解析



**跨网段 ARP 解析（ARP 代理）：**
    由于路由器会隔绝两个不同网段之间的广播，所以如果主机 A 和 主机 B 不在同一个网段，那么主机 A 是收不到主机 B 的 ARP 响应报文的。
    1）所以主机 A 需要跟主机 B 通信，但是却不知道主机 B 的 MAC 地址时，主机 A 通过子网掩码发现主机 B 的 IP 不在同个网段中，那么就需要通过网关（路由器）来发送，如果主机 A 只知道网关 G 的 IP 地址（我们网络配置的默认网关 IP），那么需要进行一次同网段的 ARP 解析（ARP 请求报文中目的 IP 为网关 G 的 IP），然后获取到网关 G 的 MAC 地址，主机 A 缓存网关 G 的 MAC 地址。
    2）此时的 ARP 解析实际上已经完成了。



这里讲下跨网段情况下主机 A 缓存了网关 A 的 MAC 地址后，如何跟主机 B 进行通信：
    1）主机 A 发送给主机 B 的消息是通过交换机先发送网关 A 的，此时消息信息为 源 IP（主机 A）、目的 IP（主机 B）、源 MAC（主机 A）、目的 MAC（网关 A）
    2）网关 A 收到消息后，如果网关 A 和 主机 B 在同个网段（上面也说了路由器是多网段的），那么一次同网段 ARP 解析获取主机 B 的地址，然后网关 A 再将消息发送给数据链路层（交换机）发送给主机 B
    3）如果 网关 A 和 主机 B 不在同个网段，中间需要经过多个路由器，那么网关会根据 目的 IP 找到下一跳的网关 B 地址，如果不存在网关 B 的 MAC，那么进行一次 ARP 解析，获取网关 B 的 MAC 地址，然后交给数据链路层，数据链路层封装的数据帧头部为 源 MAC（网关 A）、目的 MAC（网关 B），然后通过交换机发送给网关 B。网关 B 收到后，按照同样的方法，直接路由转发到主机 B
    4）主机 B 收到消息后，如果要给主机 A 发送消息，那么也是按照这种方法往回发



> #### 5、TCP 三次握手 / SSL 四次握手

在没有指定 http/https 协议的情况下，浏览器默认会访问 http 协议
www.baidu.com 如果是 https 协议，服务器会同时监听 https 和 http 的 80 端口
访问过程如下：
1）以 HTTP 的方式建立 TCP 三次握手，然后发送 HTTP 请求
2）服务器收到后，响应 302 状态码（临时重定向），让浏览器以 HTTPS 的方式访问
3）浏览器以 HTTPS 协议建立 TCP 三次握手 + SSL 四次挥手，再发送 HTTP 请求

​    

> #### 6、服务器响应请求，返回资源



> #### 7、判断是否缓存资源以及缓存资源是否改变

浏览器接收服务器响应

如果是缓存过期发起的请求，如果服务器响应 304，那么资源未改变，浏览器继续使用原来的缓存，否则更新缓存
如果是不存在缓存而发起的请求，那么根据响应头的 cache-control 判断是否缓存资源



> #### 8、html 解析、渲染

进行 html 的解析，在 html 中可能会需要一些 js、css、图片等
如果是 HTTP 1.1，那么需要将重新发起多个请求来一一获取这些资源
如果是 HTTP 2.0，如果开启了服务推送功能，那么服务器会进行推送，无需再次发起请求（**服务器推送是 HTTP 2.0 唯一一个需要手动配置的**）





## 4、cookie、session、token

```java
HTTP 是无状态的，在单单 HTTP 协议中，服务器不会去记录上一次请求的是谁，以及谁是否已经请求过了
但是随着网络技术的发展，不想改动 HTTP 协议又想保持状态，比如登录状态，不想每次访问都去登录，因此需要另外的一种机制来跟 HTTP 协议配合使用
cookie 机制 和 session 机制就是为此诞生

1、cookie 机制：
cookie 和 session 不是同时出现的， cookie 要比 session 更早出现
ccokie 机制要求浏览器来存储数据，比如登录，用户在第一次访问的时候，请求发送到服务器，服务器发现用户没有登录，那么会让用户跳转到登录页面，在用户登录完成后，服务器会创建一个 cookie，然后将用户的信息设置到 cookie 中，这样用户后续请求的时候只要携带上这个 cookie，服务器通过 cookie 可以得知用户已经登录，那么就不会再让用户跳转到登录页面。

cookie 是一段文本，存储的是 key-value 的键值对，比如 name = "张三" 之类的
它的默认大小为 4KB，即存储的数据是有限的

cookie 的类型：
1)如果没有设置过期时间，那么 cookie 是存储在内存中的，它的生命周期只在浏览器打开的期间，一旦关闭浏览器，那么 cookie 就会失效，这种 cookie 叫做 “session cookie”（会话 cookie）
2)如果设置了过期时间，那么 cookie 会被持久化到磁盘上，这样的话在过期时间内，即使浏览器关闭了，那么 cookie 还是存在的，这种 cookie 叫做 "persistent cookie"（持久化 cookie）

cookie 的缺点：
1）cookie 的存储大小和数据类型是有限的，一个 cookie 默认是 4KB，并且只能存储 key-value 形式的文本
2）cookie 存储在浏览器，容易被人 篡改 和 盗用，不安全，比如容易发生 CSRF 攻击


2、session 机制
为了解决 cookie 的不安全问题，出现了 session 机制
session 机制是使用一个叫 session 的数据结构来存储用户的信息的
当用户第一次访问时，服务器会为该用户创建一个 session，然后将 session 存储在服务器的内存上（可以持久化到文件、缓存中）
使用这种机制的话，那么就需要一种机制来标识哪个 session 属于哪个用户，因此每个 session 会存在一个 JSESSIONID，可以认为是 key-value 的映射关系。

而 session 机制一般情况下需要借助 cookie 机制来实现，服务器保存 session 和 JSESSIONID，浏览器通过 cookie 保存 JSESSIONID，在后续访问的时候，只需要携带上 cookie 然后服务器根据 cookie 中的 JSESSIONID 获取对应的 session 即可。
用户信息是存储在服务器的，不用担心被盗用和篡改。

session 机制的缺点：
1）session 存储在服务器内存，容易造成服务器的压力
2）在集群环境下，session 只会存在于第一次用户访问的服务器，如果下一次用户访问的是别的服务器，那么会导致用户的状态丢失（这里可以使用 粘性 session、session 复制、redis 存储 session 来解决）

cookie 和 session 的区别：
1）cookie 存储在客户端，相对来说不安全，容易被黑客攻击，session 存储在服务器，比较安全
2）cookie 的容量和存储的数据类型是有限的，session 则没有这方面的限制

如果 cookie 被禁用了，有两种方法：
1）让 浏览器只保存 JSESSIONID，然后在请求的时候将 JSESSIONID 放到 URL 上
2）使用 token 来代替 session（JWT）


3、JWT：
JWT 分为三部分：header、payload（载荷）、签名

header 存储 token 类型（比如 JWT）和 生成签名时的散列算法
payload 存储 token 的信息，比如过期时间、颁发的服务器、颁发给的用户
使用 base64 将 header 和 payload 进行编码（注意不是散列算法），方便传输
然后使用 "." 串起来，比如
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0

然后再选定一个密钥 secret，使用 header 头部指定的散列算法对这串字符串进行 hash 计算，得到签名/信息摘要，再串到上面的字符串上去，变成：
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM

可以看出，header 和 payload 是明文的，因此 JWT 不能用来存储敏感信息，并且一个 JWT 具有一次性，不能直接实现续签，因为一旦修改了一点信息，那么它的签名都会发生改变

在验证的时候，使用 header、payload、secret 再经过相同的计算得到签名，跟 JWT 上面的签名进行比较即可（跟 CA 证书的验证差不多）
```



## 5、子网划分、子网掩码、网络段、主机号、私网、公网

```
所有的 IP 地址为 [00000000 00000000 00000000 00000000] - [11111111 11111111 11111111 11111111]
				0.0.0.0 - 255.255.255.255

IP 地址分为 A、B、C、D、E 类地址，
A 类地址中，8bit 为网络号，24bit 为主机号，子网掩码为 255.0.0.0
B 类地址中，16bit 为网络号，16bit 为主机号，子网掩码为 255.255.0.0
C 类地址中，24bit 为网络号，8bit 为主机号，子网掩码为 255.255.255.0

子网掩码的作用：
每个网络号称之为网段，通过 子网掩码 & IP 地址 来将 IP 地址中的主机号置 0，忽略掉两个 IP 地址的主机号差异，保留网络号，以此来知道 源 IP 地址 和 目的 IP 地址是否处于同一个网段

C 类地址，一个网段可以同时存在 2^8 - 2 = 254 个主机
	（主机号范围为 00000000 - 11111111， 共 256 ，除去 全 0 和 全 1 有特殊作用，一个网段可以存在 254 个主机号）
在同个网段中的主机，可以直接通信，不需要经过网关
	比如 192.168.1.2 和 192.168.1.5 可以直接通信，它们在同个网段 192.168.1.0 中，主机号分别为 2 和 5
不同的网段主机不能直接通信，需要经过网关
	比如 192.168.1.2 和 192.168.2.5 不能直接通信，它们在不同网段 192.168.1.0 和 192.168.2.0 中
网关是用来连接两个不同网段的设备，比如 192.168.1.0 和 192.168.2.0 之间可以通过网关进行连接

什么是子网划分？
默认情况下分配的是一个网段，比如 C 类网段 192.168.1.0，它含有 254 个主机号，同时也是一个子网。
而更细的子网划分，这个 C 类网段可以再划分出子网，比如划分为两个大小相同的子网，子网掩码为 255.255.255.128，这样 子网 1 的主机号范围为 
[192.168.1.1 - 192.168.1.127]，子网 2 的主机号范围为 [192.168.1.128 - 192.168.1.254]

子网划分的好处：
1）减少广播的范围：一个子网可以认为就是一个网段，通过网关隔绝不同的网段，使得广播包只能在某个网段中传输，网络规模小了，占用的资源也少。
	这就是通过网关来隔绝广播域
2）节省 IP 资源：比如一个公司作为一个子网通信，内部只有 20 台计算机，那么如果直接分配一个 C 类网段 192.168.1.0，那么它只会占用这个 C 类地址的 20 个 IP，剩下的会浪费了，所以它可以对这个 C 类网段再进行划分，划分为多个子网，然后分其中一个子网给这个公司，剩下的子网分给别的公司


公网、私网：
首先我们先认为所有的 IP 地址都是公网，公网是能够在全球进行通信的，它就是上面划分的 A、B、C 类地址
而有的时候，一些计算机并不需要更全世界进行通信，只需要在我们这个局域网中进行通信，这时候为了节省 IP ，不可能每台主机都分配一个公网 IP，因此，它将 A、B、C 类地址中一部分地址划分出来，从公网 IP 变成 私网 IP，只要看到这些 IP，就知道是私网 IP：
A 类私网 IP：10.0.0.0-10.255.255.255
B 类私网 IP：172.16.0.0-172.31.255.255
C 类私网 IP：192.168.0.0-192.168.255.255
这些 IP 只能用于局域网通信，不能在全球通信，而这些私网 IP 在一个局域网中是不能重复的，否则一个 IP 指向多个主机，这就会产生混乱。而在不同的局域网中是可以重复的，反正也不会使用这个互相通信，重复了也没问题，因此可以进行复用。
而这些私网 IP 的计算机要跟外部进行通信，那么就需要转换为 公网 IP，由于 公网 IP 有限，所以多个私网 IP 共用一个公网 IP，通过 NAT 技术来实现。
```

