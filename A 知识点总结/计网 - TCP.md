# 计网 - TCP（传输控制协议）



## TCP 三次握手 / 四次挥手

```
1、TCP 三次握手
第一次握手：发送方初始化一个随机数 seq1 作为序列号，将 SYN 标志位置 1，将报文发送给接收方，处于 SYN_SENT 状态
第二次握手：接收方收到后，初始化一个随机数 seq2 作为序列化，将 ack 设置为 seq1 + 1，将 SYN、ACK 标志位置 1，发送给发送方，处于 SYN_RECV 状态
第三次握手：发送方收到后，返回一个 ACK 报文，seq = seq1+1, ack 设置为 seq2 + 1，发送给接收方，此时处于 ESxxx（建立）状态
接收方收到后，处于 ESxxx（建立）状态

为什么不能是两次握手？
有 3 个原因：
    1）确认双方的发送和接收能力都正常
    2）避免历史连接：比如发送方第一次发送了 SYN，结果由于网络拥堵，发送方再次发送一个 SYN，此时第一个 SYN 到达接收方，接收方回应 SYN + ACK，发送方再回应 ACK，而此时第二次发送的 SYN 也到达了，如果只有两次握手，那么接收方自己并不知道它是历史连接，将它放入到 SYN 队列中，然后回应 ACK，这样就会导致重复连接。而如果是三次握手，在第三次握手中发送方发现这是历史连接，可以发出 RST 中止这个历史连接
    3）确保双方都同步了初始序列号：初始序列号在后续的传输中极其重要，如果只有两次握手，那么接收方并不清楚发送方是否已经同步了自己的初始序列号

为什么不能是四次握手?
    如果是四次握手，那么过程如下：
        第一次握手：发送 SYN
        第二次握手：发送 ACK
        第三次握手：发送 SYN + ACK
        第四次握手：发送 ACK
    跟四次挥手不一样，第二次握手和第三次握手之间不需要什么处理，所以可以直接将第二次握手和第三次握手进行合并

为什么要使用随机初始序列号？
	为了安全性，随机初始序列号是告知对方我们要发送的数据是在这个偏移量上的，比如随机初始序列号为 1000，然后我发送了 1 号字节，那么发送出去的数据的序列号为 1001，减去初始序列号后变成了 1，即发送的数据是整个数据的 1 号字节数据
	如果 TCP 的数据发送都从 0 号开始，那么黑客可以很简单的猜测到 报文的序列号和确认号，从而可以伪造 TCP 报文，比如发送一个 RSET 报文，接收方发现序列号和确认号是对的，所以直接中止了连接。所以使用随机序列号的作用是为了减少黑客攻击成功的几率。因此三次握手同步初始序列号是很重要的
	

2、TCP 四次挥手
第一次挥手：发送方创建一个 TCP 报文（后面都忽略掉这个步骤），将 FIN、ACK 标志位置 1，发送给接收方，此时处于 FIN_WAIT1 状态
第二次挥手：接收方收到，先发送一个 ACK 报文，告知发送方自己收到终止请求，不过此时自己可能有数据还需要处理或者发送，所以此时接收方不会立马发送 FIN 报文，此时处于 CLOSE_WAIT 状态
发送方收到 ACK 报文后，处于 FIN_WAIT2 状态
第三次挥手：接收方处理完数据后，发送 FIN + ACK 报文，此时处于 LAST_ACK 状态
第四次挥手：发送方收到后，发送 ACK 报文，此时处于 TIME_WAIT 状态，这里一般是 2MSL
接受方收到后，进入 CLOSED 状态，发送方 TIME_WAIT 过后，自动进入 CLOSED 状态


为什么需要 TIME_WAIT?
[为什么 TCP 协议有 TIME_WAIT 状态](https://draveness.me/whys-the-design-tcp-time-wait/)
1）为了让被动关闭方能够正常的收到 FIN 的 ACK 然后正常关闭：如果客户端返回 ACK 后就直接进入 CLOSED 状态，如果这个 ACK 在网络中丢失了，那么服务端没有收到，这段时间会一直处于 LAST_ACK 状态，如果这段时间客户端重用了刚刚的四元组发起 SYN 请求，那么服务器会返回一个 RST 终止连接
2）让旧的数据包在网络中消失，不会出现在新的连接上：如果发送完 ACK 直接进入 CLOSED，客户端重用连接，那么在网络中原本属于旧的连接的数据包可能会到达这个新的连接上，导致混乱。

TIME_WAIT 为什么是 2MSL？
1）报文的最大有效时间是 MSL，一旦超过这个时间，那么网络中的报文就无效了，等待 2MSL 必定能使属于此次连接的数据包无效，而不会应用到下一次新的连接中
2）当发送方第四次握手发送 ACK 后，这个报文能够到达接收方的临界时间为 MSL，而接收方在等待了一段时间后，重新发送 FIN + ACK包，这个临界时间也是 MSL，就是当作 ACK 刚刚到达接收方前，接收方又重发了 FIN 这种极端情况，这样的话就又最大需要等待 MSL，如果在这个 2MSL 时间内没有收到 FIN，那么就可以关闭了，因为即使有旧的 FIN + ACK 也已经经过 MSL 无效了

```





## TCP 三次握手可能遭受的攻击

### 1、SYN 攻击

```
在服务端收到客户端第一次握手时，会将该连接存储到 SYN 队列中（半连接队列），攻击者可以伪造 IP 不断发送 SYN 请求，
服务端会响应 SYN+ACK，但是由于这是攻击，所以攻击者不会响应 ACK，这样就会导致服务端的 SYN 队列被挤满，
这样其他正常的 SYN 连接请求就会被丢弃
```

解决方法：

```
1、减少 SYN timeout 的时间（缩短时间，这样霸占在 SYN 队列中的连接在 timeout 时间后会失效）
2、使用 SYN cookie，使用 客户端IP、端口、服务器IP、端口 以及一些安全数值 进行散列运算得到一段信息摘要，这个信息摘要就是 SYN cookie，
	将这个 SYN cookie 代替第二次握手服务端初始化的随机数 作为序列号 seq，然后不将此次连接存储到 SYN 队列，
	当收到第三次握手的报文后，将报文的 ack-1，得到信息摘要1，然后使用相同的数据进行散列运算得到信息摘要2，进行对比，
	一致的话表示没有问题，那么将该连接存储到 Accept 队列中（类似于 CA 证书的校验）

不直接全部采用 SYN cookie 的原因：
计算和验证 SYN cookie 需要 CPU 进行大量计算，如果在高并发的情况下，那么会占用很多的 CPU 资源
```



### 2、Land 攻击

```
攻击者会发起 源IP 和 目的IP 都是 目标主机IP（服务器IP） 的 SYN 报文，这样当服务端收到后会发送一个 SYN+ACK 报文，此时报文的 目的IP 是它自己，攻击者不断发送 SYN 报文会导致服务端不断给自己发送报文，从而导致系统崩溃
```



解决方法：

```
对报文的源IP和目的IP进行校验，如果一致的话可以确定为 Land 攻击
```



## TCP 可靠性实现

1、序列号和确认号

2、超时重传、快速重传

3、基于滑动窗口的流量控制

4、拥塞控制



拥塞控制的作用：

```
基于滑动窗口的流量控制是接收方为了限制发送方的发送数据量，通过窗口通告来告知发送方自己还能够接收多少数据，避免发送方一股脑发送数据导致数据无法被接收从而丢失，无意义地占用网络带宽，流量控制是点对点的。
而网络中实际上是存在多个主机进行通信的，它们的数据包都可能会经过同一个路由器，而每个路由器的处理速率是有限的，如果网络中充斥过多的数据包而不能及时地转发处理，那么数据包存活时间超过 MSL 变成无效数据，那么该数据包是无效传输，浪费网络带宽。
因此发送方数据的发送还需要考虑到整体的网络环境，这就是拥塞控制的作用。

发送方除了会维护滑动窗口，还会维护一个拥塞窗口 cwnd，该窗口用来控制发送方可发送的数据量，比如滑动窗口大小为 3MSS，而拥塞窗口大小为 MSS，那么此次发送方只能够发送一个大小为 MSS 的报文段，直到收到该报文段的 ACK 后才能够继续发送。
```



> #### 1、慢启动

发送方维护拥塞窗口 cwnd，初始值为 1，表示可以发送一个 MSS 大小的报文段，比如 MSS = 1024，那么发送方最开始可以发送 1024B 数据

每收到一个新的 ACK，那么 cwnd + 1

那么慢启动 cwnd 增长如下：

1）、cwnd = 1，收到 1 个新的 ACK，那么 cwnd + 1 = 2

2）、cwnd = 2，收到  1 个新的 ACK，cwnd + 1 = 3，再次收到一个新的 ACK，那么 cwnd + 1 = 4

（当然如果只收到一个新的 ACK，而这个 ACK 是对前面两个报文的累计确认，那么同样的 cwnd + 2）

以此类推。。。

可以看出慢启动阶段发送方 cwnd 是指数增长的，但是这肯定是有限制的，存在一个慢启动阈值 ssthresh，当 cwnd == ssthresh 时就会进入拥塞避免。



> #### 2、拥塞避免

当 cwnd == ssthresh 时进入拥塞避免算法

比如 cwnd = 8, ssthresh = 8，

拥塞避免算法 cwnd 增长如下：

1）、cwnd = 8，每收到一个新的 ACK，那么 cwnd + 1/cwnd = 8 + 1/8。只有收到  8 个新的 ACK，cwnd 才能够多发送一个 MSS 大小的报文

以此类推。。。

可以看出拥塞避免阶段发送方 cwnd 是线性增长的。

需要注意的是并不是 cwnd 多少就能发送多少个 MSS 大小的报文，发送方实际的发送量是跟滑动窗口挂钩的，因此如果  cwnd = 1024，而滑动窗口大小为 512，那么发送方也只能发送 512B 数据



> #### 3、快速重启

慢启动和拥塞避免的过程中不可能是一帆风顺的，难免会出现丢包情况，而一旦出现丢包就意味着网络可能发生拥堵，那么这时候就需要降低往网络中发包的速率，避免加重网络拥塞，慢慢等待网络中的数据包减少。

而实际上当报文丢包或者报文乱序到达，接收方都不能够按照正常顺序接收到数据包，因此它每收到一个乱序包就会发送一个重复 ACK，而发送方实际上并不知道这个重复 ACK 是由于报文丢包还是报文乱序到达导致的，那么发送方就是等待少量的重复 ACK 到来

假设发送方发送了 3 个报文 N-1，N，N+1，如果是报文乱序，那么只可能会产生 1-2 个重复的 ACK，如果是 3个或3个以上的重复 ACK，小概率是报文乱序，大概率是报文丢失，因此不等待超时重传定时器到达时间，直接将该报文重传，同时进入快速恢复算法。



> #### 4、快速恢复算法

将 cwnd 砍半，然后让 ssthresh 等于 cwnd，即 cwnd = cwnd / 2，ssthresh = cwnd，然后 cwnd += 3

然后开始发送，每次收到一个重复的 ACK，那么 cwnd + 1

直到收到新的 ACK 后，那么将 cwnd = ssthresh，此时由于 cwnd 达到慢启动阈值，所以会进去拥塞避免算法



需要注意的是，如果没有触发快速重传和快速恢复，那么将会超时重传定时器到达时间后进行超时重传，此时就会将 cwnd = 1，然后重新开始慢启动算法，快速重传和快速恢复的目的就是为了尽可能地不重新开始慢启动，导致传输效率降低





## TCP 综合问题

> #### 1、客户端连续三次 write()，服务端分别可能需要调用多少次 read()

```
理想状态下，不丢包，服务端都能够进行接收处理，那么服务端只需要调用一次 read()
丢包情况：
	1）、丢了一个包，重发这个包，这个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	2）、丢了两个包，重发这两个包，两个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	3）、丢了两个包，重发这两个包，一个包正常到达，另一个包再次丢失，再次重发，正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取第一次重发的数据，第三次 read() 读取第二次重发的数据
```



> #### 2、客户端发送问题

MTU = 1000byte

客户端调用两次 write()，每次写入 600 byte，那么客户端会发送多少次，每次数据为多少？

```
在服务端可处理的情况下，客户端第一次发送的数据为 1000byte，第二次发送的数据为 200byte
```

第一次发送后第二次发送是立刻发送还是会等一会才发送？

```
根据 TCP 参数配置，默认情况下是会等一会才发送的，因为剩下的 200byte 属于小包，TCP 为了避免频繁的小包发送开启了 Nagle 算法，只有等待超时或者包数据到达一定量或者包存在FIN标识符等才会发送处理
如果我们关闭了 Nagle 算法，并且服务端可处理的情况下，包会立马发送
```



> #### 3、SYN 队列满了，那么接收方会怎么做？

```
默认情况下，如果没有开启 SYN cookie，那么接收方会直接丢弃连接，什么都不回复，发送方在没有收到 SYN + ACK 时会继续重发一定的次数，如果重发次数这段期间 SYN 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么发送方就不会再重发 SYN 了，那么 SYN 队列如果空出来了也没有机会建立连接
```



> #### 4、Accept 队列满了，那么接收方会怎么做？

```
默认情况下，接收方会忽略掉第三次握手发送方的 ACK，然后重发 SYN+ACK，重试直到发送方超时，如果这段期间 Accept 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么 Accept 队列如果空出来了也没有机会建立连接
```



> #### 5、窗口通告 和 窗口关闭

接收方收到数据后返回 ACK 报文，在 TCP 报文头部有 `窗口大小`字段，该字段用来通告对方自己的TCP接收缓冲区还能接收多少字节数据，以此来控制对方的滑动窗口大小，实现流量控制

当服务端没有过于繁忙而没有及时处理数据，那么会导致接收缓冲区堆积满，发送方将可发送的数据全部发送导致窗口大小为 0，那么它将会一直等待服务端的 ACK 来通告窗口大小，如果服务端的 ACK 丢失了，那么双方都会陷入等待状态，以此陷入死锁。

因此，TCP 的设计是当发送方窗口大小为 0 时，那么会开启一个定时器，当定时器到达时间后发送方还没有收到一个窗口通告，那么就会发送一个 `窗口探测`报文，该报文包含 1B 数据，是下一个将要发送的字节数据，比如接收方期望的 ack = 1000，那么此时发送的窗口探测报文的 seq = 1000，长度为 1

1）、如果接收方处理了部分数据能够正常接收这个字节数据，那么返回的 ACK 报文 ack = 1001，同时通报窗口大小，如果通报的窗口大小 > 0，那么发送方关闭定时器，如果通报的窗口大小 = 0，那么继续复位定时器，同时发送 seq = 1001 的字节数据作为窗口探测报文。

2）、如果接收方不能正常接收这个字节数据，那么该字节数据会继续会持续重发作为窗口探测报文

**窗口探测的定时器会一直持续到窗口打开或者进程结束**



以下是窗口探测的例子：

```
报文段 1 - 13 是正常数据传输通信，报文段 13 接收方通告窗口大小为 0，表示 TCP 接收到数据但是应用层可能由于繁忙还没有处理
此时发送方会开启一个定时器，定期进行窗口通告，报文段 14 开始发送窗口通告报文，发送的 1B 数据是接收方期望下一个接收的数据，报文段 15 是接收方对窗口探测报文的 ACK，它并没有接收这个数据，通告窗口大小为 0，因此发送方后面继续发送该字节作为窗口探测报文。。。
```

<img src="https://pic.leetcode-cn.com/1631243082-TUJfiC-image.png"  width="900"  height = "700" />



> #### 6、糊涂窗口综合症

基于滑动窗口的流量控制以及窗口通告机制，很容易出现糊涂窗口综合症

糊涂窗口综合症：

```
接收方每次通告很小的窗口，发送方收到 小窗口通告后直接将小的数据包发送到网络中，比如接收方通告窗口大小为 1，发送方就会去发送 1B 的数据包，接收方收到后处理了 1B，再次通告窗口为 1，发送方再次发送 1B 的数据包，这样网络中会充斥着这种小的数据包，而一个 1B 数据封装的 IP 报文需要占用 41B，20B IP 头部 + 20B TCP 头部，这显然是对资源的浪费，并且很可能会导致网络拥堵。
```



接收方解决：不通告小窗口，接收方在窗口大小可以增加一个报文长度（即 MSS）或者窗口大小到达接收缓冲区的一半的时候会进行窗口的通告（这里的通告是接收方主动发送 ACK）

发送方解决：开启 Nagle 算法



以下是接收方解决糊涂窗口综合症的例子：

```
报文 1 2 3 4 是发送方连续发送的 4个 1024B 报文数据 [1-4096]，报文 5 是接收方 TCP 返回 ACK 表示接收到，但是通告窗口大小为 0，表示 TCP 接收到了但是应用层还没有处理

窗口探测的定时器为 5s，每隔 5s 会进行一次窗口探测
报文 6 是发送方定时器到达时间发送的窗口探测报文，数据是接收方期望收到的下一个字节 4097，报文 7 是接收方处理了 1B 数据后再正常接收这 1B 数据，所以返回 ack = 4098，窗口大小仍然为 0，发送方继续窗口探测
报文 8 是窗口探测，发送的数据是 seq = 4098，报文 9 是 ACK, 接收方正常处理了这 1B 数据，ack = 4099，但是窗口大小为 0

。。。

报文 13 是接收方的 ACK 报文，里面通知发送方窗口大小为 509，但是虽然窗口大小不为 0，但是距离下一次发送方发送的报文 14 间隔了差不多 5s，这是因为发送方开启了 Nagle 算法，可发送数据不满足 MSS，所以不会立即发送，等待 5s 的超时时间后数据也没有到达 MSS，那么也会将这 509B 数据发送出去

报文 18 是发送方发送的最后一次数据，因此顺便带上 FIN 标志位，报文 19 是接收方收到 FIN 报文，同时接收这部分数据，通告窗口大小
报文 20 是四次握手之外的，接收方用来主动通告窗口大小，这是因为接收方处理了部分数据，窗口大小到达了接收缓冲区的一半，因此发送 ACK 主动通告发送方。

我们这里可以看出，四次挥手是常规状态下，如果这段期间接收方在从接收缓冲区中获取数据，那么可能会主动发起窗口通告
```

<img src="https://pic.leetcode-cn.com/1631244412-fVFPQc-image.png"  width="900"  height = "700" />





## TCP 知识点整理

问题：

```
TCP 如何处理重复的报文数据？
TCP 如何避免主动关闭方一直处于 FIN_WAIT2 状态？
如何避免半打开的 TCP 连接占用服务器资源？
```



![image.png](https://pic.leetcode-cn.com/1631177972-VUECjW-image.png)

<img src="https://img-blog.csdnimg.cn/20191208122542343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzU0NTcz,size_16,color_FFFFFF,t_70"  width="700"  height = "500" />





<img src="https://pic.leetcode-cn.com/1631199379-oPwUGl-image.png"  width="1000"  height = "300" />





```
TCP 不会去对传输的字节流进行任何的解释处理，TCP 并不知道这个字节流是作为二进制数据还是十六进制数据、按照 ASCII 编码还是根据 Unicode 编码，对字节流的解释全部在应用层去处理，由程序员自己去处理

URG：紧急指针标志位
SYN：请求建立连接
ACK：对前面数据的应答，同时表示期望下一个收到的字节序号
RST：重建连接/中止连接
FIN：数据发送完成，请求关闭连接
PSH：接收方应该尽快将该报文交给应用层

TCP 报文头部的源端口和目的端口是用来寻找发送方和接收方的进程的，而 IP 报文的源IP和目的IP则是用来寻找发送方和接收方的主机

TCP 可以表述为一个缺少选择确认或否认的滑动窗口协议
缺少选择确认是说 TCP 在收到 1-1024 字节的以及 2049-3072 字节的时候，它无法对 2049-3072 字节进行确认，它能做的就是返回一个 ack = 1025 的响应，由于没有确认所以客户端此时并不知道服务端是否收到了 2049-3072 字节
缺少否认是说 TCP 在收到 1-1024 字节后，再收到 1025-2048 字节，但是这段报文的检验和出现错误，那么它不能对这段报文进行否认，不能告知发送方报文出错，它只能将错误的报文进行丢弃处理，并发送 ack = 1025 的响应让发送方重新发送
（检验和：检验 TCP 报文数据是否正确，是否在发送的过程中出现了改动，由发送方计算和存储，由接收方进行验证）

TCP 滑动窗口的大小由 TCP 报文头部的窗口大小字段来控制，16bit，所以最大可发送 65535 字节

当 URG = 1 时，TCP 头部的紧急指针字段才生效，它是一个正的偏移量，表示紧张数据的最后一个字节的序号，序列号表示当前 TCP 报文数据第一个字节的序号，两者构成紧急数据。URG = 1 的数据到达接收方时不进入缓冲区直接交给上一层，因为表示紧急数据，需要加快处理。
当 PSH = 1 时，报文数据要进入缓冲区，但是不需要等缓冲区满就交给上一层，一般是用来告知接收方快点将缓冲区数据读取出去，为后续的数据发送腾出空间

MTU：最大传输单元，这是数据链路层对数据包的大小限制，超过这个限制的数据包会被丢弃，拒绝转发
MSS：最大报文长度，表示发送方每次能够发送的最大数据长度， MSS = MTU-IP报文头部-TCP 报文头部 = MTU-20-20 = MTU-40
MSS 的作用是为了避免在IP层进行分片

半关闭：一方发送完数据后关闭发送能力，但仍想要接收另一方的数据并回复 ACK
1）、发送方发送完数据后调用 close() 会关闭数据发送和接收能力（但不影响接收接收方对 FIN 的 ACK 以及发送方的 FIN 报文），这段期间如果接收方发送数据过来那么发送方会回应 RST 中止连接
2）、发送方发送完数据调用 shutdown()，发送方会关闭发送能力，但仍然存在接收能力，对于接收方调用 close() 前的这段期间发送的数据能够正常回复 ACK 并进行处理
close() 和 shutdown() 都是为了告知接收方数据已经全部发送完成了，而半关闭是为了让主动关闭方还能够接收接收方还没有发送完成的数据

FIN_WAIT2 状态是主动关闭方发送完 FIN 然后收到接收方的 ACK 后进入的状态，如果接收方忘记调用 close()，那么发送方将一直处于 FIN_WAIT2，接收方将一直处于 CLOSE_WAIT，为了避免一直处于 FIN_WAIT2 状态，采用如下设计：
	如果主动关闭方调用 close() 而不是调用 shutdown()，表示它并不需要在 FIN_WAIT2 阶段等待接收方的数据，那么在调用 close() 后开启一个定时器，当定时器超时后还没有收到 FIN 报文，那么发送方直接进入 CLOSED 状态
	（这种设计并不符合 TCP 规范，但是大部分系统都这么设计）
	
TCP 半打开连接：一方已经关闭或者异常掉线，而另一方还不知道。任何一方连接主机掉线都可能导致这种情况，如果不在半打开的连接上进行数据传输，那么仍然处于连接的一方将不会察觉到对方已经掉线，因此会一直保持着连接。
当我们作为客户端去给服务器发送信息，当发送完成后我们直接主机关机，而如果服务器没有再向客户端发送数据，那么它将认为客户端还存活，继续保持着这个连接，这种情况将会导致服务器保持着许多的半打开连接占用系统资源。

TCP 的保活机制 keep-alive： TCP 保活机制是为服务端提供的，它主要是用来解决服务端保持多个 TCP 半打开连接的问题（客户端实际上也能够开启）
服务端会为每个TCP连接维护一个默认为 2小时的定时器，当2小时内没有收到客户端的数据，那么会发送一个心跳包检测客户端是否存活
客户端可能处于以下几种情况：
	1）、客户端正常运行，回复 ACK，服务端收到响应判定客户端存活，那么将定时器重置，重新定时
	2）、客户端异常掉线，不会回复 ACK，服务端超时重发心跳包，重试10次都没有 ACK，判定客户端没有存活，将连接断开
	3）、客户端异常掉线后重新启动，收到心跳包后由于已经不维持该连接，所以回复 RST，服务端收到 RST 中止连接
	4）、客户端存活但不可达，那么跟 2）一样，重试10次后断开连接
TCP 保活心跳包：客户端期望收到的服务端的序列号为 ack，TCP 心跳包则是服务端发送 seq = ack-1 的数据报文，这样客户端收到后发现 seq 对不上，就会响应 ACK 报文，服务端收到 ACK 后以此来探测客户端存活

服务端调用 listen() 进入 LISTEN 状态，当 TCP 三次握手完成后完成 TCP 连接的建立,进入到 Accept 队列，此时应用层实际上还并不知道连接的存在，等到调用 accept() 从中获取到连接后才会知道该连接的存在，而对于客户端来说，三次握手完成后它会认为服务器已经准备好接收数据了，那么此时服务器 TCP 接收到的数据会被放入到缓冲队列中，等到应用层 accept() 获取连接后再进行读取
```



