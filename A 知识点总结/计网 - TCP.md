# 计网 - TCP



## 1、TCP 三次握手 / 四次挥手

```
1、TCP 三次握手
第一次握手：发送方创建 TCP 报文，初始化一个随机数 seq1 作为序列号，作为将 SYN 标志位置 1，发送给接收方，此时处于 SYN_SENT 状态
第二次握手：接收方收到后，创建一个 TCP 报文，初始化一个随机数 seq2 作为序列化，然后将 确认号设置为 seq1 + 1，然后将 SYN、ACK 标志位置 1，然后发送给发送方，此时处于 SYN_RECV 状态
第三次握手：发送方收到后，创建一个 TCP 报文，将序列号设置为 seq1 + 1，然后确认号设置为 seq2 + 1，将 SYN、ACK 标志位置 1，发送给接收方，此时处于 ELxxx（建立）状态
接收方收到后，处于 ELxxx（建立）状态

为什么不能是两次握手？
有 3 个原因：
    1）确认双方的发送和接收能力都正常
    2）避免历史连接：比如发送方第一次发送了 SYN，结果由于网络拥堵，发送方再次发送一个 SYN，此时第一个 SYN 到达接收方，接收方回应 SYN + ACK，发送方再回应 ACK，而此时第二次发送的 SYN 也到达了，如果只有两次握手，那么接收方自己并不知道它是历史连接，将它放入到 SYN 队列中，然后回应 ACK，这样就会导致重复连接。而如果是三次握手，在第三次握手中发送方发现这是历史连接，可以发出 RST 中止这个历史连接
    3）确保双方都同步了初始序列号：初始序列号在后续的传输中极其重要，如果只有两次握手，那么接收方并不清楚发送方是否已经同步了自己的初始序列号

为什么不能是四次握手?
    如果是四次握手，那么过程如下：
        第一次握手：发送 SYN
        第二次握手：发送 ACK
        第三次握手：发送 SYN + ACK
        第四次握手：发送 ACK
    跟四次挥手不一样，第二次握手和第三次握手之间不需要什么处理，所以可以直接将第二次握手和第三次握手进行合并

为什么要使用随机初始序列号？
	为了安全性，随机初始序列号是告知对方我们要发送的数据是在这个偏移量上的，比如随机初始序列号为 1000，然后我发送了 1 号字节，那么发送出去的数据的序列号为 1001，减去初始序列号后变成了 1，即发送的数据是整个数据的 1 号字节数据
	如果 TCP 的数据发送都从 0 号开始，那么黑客可以很简单的猜测到 报文的序列号和确认号，从而可以伪造 TCP 报文，比如发送一个 RSET 报文，接收方发现序列号和确认号是对的，所以直接中止了连接。所以使用随机序列号的作用是为了减少黑客攻击成功的几率。因此三次握手同步初始序列号是很重要的
	

2、TCP 四次挥手
第一次挥手：发送方创建一个 TCP 报文（后面都忽略掉这个步骤），将 FIN、ACK 标志位置 1，发送给接收方，此时处于 FIN_WAIT1 状态
第二次挥手：接收方收到，先发送一个 ACK 报文，告知发送方自己收到终止请求，不过此时自己可能有数据还需要处理或者发送，所以此时接收方不会立马发送 FIN 报文，此时处于 CLOSE_WAIT 状态
发送方收到 ACK 报文后，处于 FIN_WAIT2 状态
第三次挥手：接收方处理完数据后，发送 FIN + ACK 报文，此时处于 LAST_ACK 状态
第四次挥手：发送方收到后，发送 ACK 报文，此时处于 TIME_WAIT 状态，这里一般是 2MSL
接受方收到后，进入 CLOSED 状态，发送方 TIME_WAIT 过后，自动进入 CLOSED 状态


为什么需要 TIME_WAIT?
[为什么 TCP 协议有 TIME_WAIT 状态](https://draveness.me/whys-the-design-tcp-time-wait/)
1）为了让被动关闭方能够正常的收到 FIN 的 ACK 然后正常关闭：如果客户端返回 ACK 后就直接进入 CLOSED 状态，如果这个 ACK 在网络中丢失了，那么服务端没有收到，这段时间会一直处于 LAST_ACK 状态，如果这段时间客户端重用了刚刚的四元组发起 SYN 请求，那么服务器会返回一个 RST 终止连接
2）让旧的数据包在网络中消失，不会出现在新的连接上：如果发送完 ACK 直接进入 CLOSED，客户端重用连接，那么在网络中原本属于旧的连接的数据包可能会到达这个新的连接上，导致混乱。

TIME_WAIT 为什么是 2MSL？
1）报文的最大有效时间是 MSL，一旦超过这个时间，那么网络中的报文就无效了，等待 2MSL 必定能使属于此次连接的数据包无效，而不会应用到下一次新的连接中
2）当发送方第四次握手发送 ACK 后，这个报文能够到达接收方的临界时间为 MSL，而接收方在等待了一段时间后，重新发送 FIN + ACK包，这个临界时间也是 MSL，就是当作 ACK 刚刚到达接收方前，接收方又重发了 FIN 这种极端情况，这样的话就又最大需要等待 MSL，如果在这个 2MSL 时间内没有收到 FIN，那么就可以关闭了，因为即使有旧的 FIN + ACK 也已经经过 MSL 无效了

```





## 2、TCP 三次握手可能遭受的攻击

### 1、SYN 攻击

```
在服务端收到客户端第一次握手时，会将该连接存储到 SYN 队列中（半连接队列），攻击者可以伪造 IP 不断发送 SYN 请求，
服务端会响应 SYN+ACK，但是由于这是攻击，所以攻击者不会响应 ACK，这样就会导致服务端的 SYN 队列被挤满，
这样其他正常的 SYN 连接请求就会被丢弃
```

解决方法：

```
1、减少 SYN timeout 的时间（缩短时间，这样霸占在 SYN 队列中的连接在 timeout 时间后会失效）
2、使用 SYN cookie，使用 客户端IP、端口、服务器IP、端口 以及一些安全数值 进行散列运算得到一段信息摘要，这个信息摘要就是 SYN cookie，
	将这个 SYN cookie 代替第二次握手服务端初始化的随机数 作为序列号 seq，然后不将此次连接存储到 SYN 队列，
	当收到第三次握手的报文后，将报文的 ack-1，得到信息摘要1，然后使用相同的数据进行散列运算得到信息摘要2，进行对比，
	一致的话表示没有问题，那么将该连接存储到 Accept 队列中（类似于 CA 证书的校验）

不直接全部采用 SYN cookie 的原因：
计算和验证 SYN cookie 需要 CPU 进行大量计算，如果在高并发的情况下，那么会占用很多的 CPU 资源
```



### 2、Land 攻击

```
攻击者会发起 源IP 和 目的IP 都是 目标主机IP（服务器IP） 的 SYN 报文，这样当服务端收到后会发送一个 SYN+ACK 报文，此时报文的 目的IP 是它自己，攻击者不断发送 SYN 报文会导致服务端不断给自己发送报文，从而导致系统崩溃
```



解决方法：

```
对报文的源IP和目的IP进行校验，如果一致的话可以确定为 Land 攻击
```



## 3、TCP 可靠性实现

```
1、序列号和确认号机制


2、超时重传、快速重传


3、滑动窗口

滑动窗口出现的目的：
1）提高发送的效率，不再是发送一个包就等待一个 ACK，而是采用累计确认的方式
2）为了实现流量控制

在传统的 TCP 中，由于 TCP 要保证可靠传输，同时要保证有序性，所以它提供可靠性的是发一个包就等待一个包的 ACK，并且按照顺序发送包，发送包1，需要等待包1 的 ACK，才能继续发送包2，这样就保证了可靠性和有序性。
这个方法的问题在于：效率太低，这明显是很有问题的。

因此出现了滑动窗口机制，它能够同时发送多个包，并且如果多个包都收到了，那么就直接发送最后一个包的 ACK，表示该包包括前面的所有包都收到了，这就是累计确认；
同时如果同时发送包1、包2、包3，其中包2丢失了，接收方处理好了 包1 和 包3，但是没有包 2，所以它会回应 ACK = 包2，表示没有收到包2，因此发送方会重发包2，接收方收到包2，处理完后，发现包3 也处理了，因此会发送 ACK = 包4
如果接收方收到重复的已处理的包，那么会发送 ACK 告知已经处理

    滑动窗口分为三个指针：字节流中已经发送的并且已经 ACK 的 offset 位置、已经发送但未 ACK 的 offset 位置，剩下的可发送的最后一个字节的 offset 位置
    TCP 发送缓冲区字节流：
    1	2	3	4	5	6	7	8	9	10	11	12	13	14
			👆				👆					👆
			i				j					k
	指针 i 表示该位置以及前面的数据已经发送并且已经收到 ACK，没有它们什么事了，可以直接舍弃
	指针 j 表示 [i + 1, j] 之间的数据是已经发送，但是未收到 ACK 的，需要保留，如果需要的话就进行重传
	指针 k 表示 [j + 1, k] 之间的数据是未发送，但是是可发送的，即表示接收方现在 buffer 缓冲区的可用大小，这些数据可以不用等待前面数据 ACK，可以直接发送
	指针 k 后面的数据表示未发送，并且也不能发送


4、流量控制（利用滑动窗口实现）
流量控制是针对一个 TCP 连接来说的，通过流量控制来限制发送方的发送数据量
如果没有对发送方的发送数据量进行限制，一股脑的有多少数据就发送多少数据，那么接收方处理不过来，会导致数据丢失
因此，发送方需要根据接收方的处理能力来发送数据，即接收方的 buffer 还能够存储多少数据。

滑动窗口的概念实际上是位于发送方的，表示已经发送了哪些数据，剩下的还可以再发送哪些数据，只不过窗口的大小是通过接收方来决定的

发送方会维护一个变量 receive window，简称 rwnd，它是用来记录接收方的 buffer 还可以存储多少数据
而这个数据实际上是接收方告知发送方的，在每次回复 ACK 的时候，接收方都会把 rwnd 的大小告知发送方，发送方通过这个变量来控制发送的数据量

在发送窗口为 0 的时候，接收方在处理完数据后不会主动告知 rwnd 大小，因此这时候 发送发会不断发送 1B 数据包给接收方，当接收方处理完数据，能够接收到这 1B 数据后，那么就会发送 ACK 同时告知 rwnd 的大小，让发送继续发送数据
	（这里为了避免网络中只有小数据包，即糊涂窗口综合征，所以会默认开启 Negle 算法，同时也会导致粘包、拆包问题）
    
   
5、拥塞控制(利用拥塞窗口实现)
拥塞控制是针对整个网络环境来说的，发送方不是单单维护一个滑动窗口，还需要维护一个拥塞窗口
不是接收方告知发送方 rwnd，那么发送方就直接发送 rwnd 的数据，而是需要根据整个网络环境来说，避免整个网络环境发生拥堵
所以需要通过拥塞窗口来控制发送的速率
也就是说，滑动窗口是接收方用来控制发送方的发送数据量，而拥塞窗口是用来控制发送方的发送速率的，一个是考虑接收方的接收能力，一个是考虑网络环境的拥堵情况


1）慢启动：刚建立 TCP 连接时，不会立马发送大数据，而是会一点一点提高数据量
指定拥塞窗口 cwnd = 1，表示只能发送 1MSS 的数据量
当收到 1 个 ACK 后，cwnd + 1
当收到 2 个 ACK 后，cwnd + 2
当收到 4 个 ACK 后，cwnd + 4
。。。
它发送的数据量是层指数增长的

2）拥塞避免：慢启动可以让发送速率很快到达一个理想的值，但不可能一直指数增长下去，所以设置了一个慢启动阈值 ssthresh
当 cwnd 到达这个阈值时，进入拥塞避免算法
假设 cwnd = 8，那么它只有收到 8 个 ACK 后，cwnd + 1
后续收到 9个 ACK 后，cwnd + 1
即开始线性增长

3、快重传和快恢复
在快重传和快恢复还没有出现时，一旦丢包，出现超时重传，TCP 就认为是网络拥堵，那么就会重新开始慢启动过程，这样的话，就会导致在没有网络拥堵的情况下发送速率也降低了
因此出现了快重传和快恢复

如果在超时时间内收到 3 个重复的 ACK 时，那么不需要等待超时重传，开启快重传算法
如果在超时时间内没有收到 3 个重复 ACK，那么重新进行慢启动算法
				（因为出现重复 3 个 ACK 时丢包的概率比乱序的概率要大得多）
快重传：
	1）重传丢失的数据包
    2）将 cwnd 缩减为一半，再将慢启动阈值设置为 cwnd，即 cwnd = cwnd / 2, ssthresh = cwnd
    3）进入快速恢复算法

快恢复：
    1）将 cwnd = cwnd + 3
    	（为什么 +3？因为它认为已经收到 3 个重复的数据包了，那么表示网络中已经减少了 3个包，可以再放三个包进去）
    2）往后收到重复的 ACK，那么 cwnd +1
    3）如果收到新的 ACK，表示接收方已经收到新的数据包了，将 cwnd 设置为 ssthresh，退出快速恢复算法，由于 cwnd == ssthresh，所以开始拥塞避免算法
```

<img src="https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120313249-1589098511.png" style="zoom:60%;" />









## 4、TCP 综合问题

> #### 1、客户端连续三次 write()，服务端分别可能需要调用多少次 read()

```
理想状态下，不丢包，服务端都能够进行接收处理，那么服务端只需要调用一次 read()
丢包情况：
	1）、丢了一个包，重发这个包，这个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	2）、丢了两个包，重发这两个包，两个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	3）、丢了两个包，重发这两个包，一个包正常到达，另一个包再次丢失，再次重发，正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取第一次重发的数据，第三次 read() 读取第二次重发的数据
```



> #### 2、客户端发送问题

MTU = 1000byte

客户端调用两次 write()，每次写入 600 byte，那么客户端会发送多少次，每次数据为多少？

```
在服务端可处理的情况下，客户端第一次发送的数据为 1000byte，第二次发送的数据为 200byte
```

第一次发送后第二次发送是立刻发送还是会等一会才发送？

```
根据 TCP 参数配置，默认情况下是会等一会才发送的，因为剩下的 200byte 属于小包，TCP 为了避免频繁的小包发送开启了 Nagle 算法，只有等待超时或者包数据到达一定量或者包存在FIN标识符等才会发送处理
如果我们关闭了 Nagle 算法，并且服务端可处理的情况下，包会立马发送
```



> #### 3、SYN 队列满了，那么接收方会怎么做？

```
默认情况下，如果没有开启 SYN cookie，那么接收方会直接丢弃连接，什么都不回复，发送方在没有收到 SYN + ACK 时会继续重发一定的次数，如果重发次数这段期间 SYN 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么发送方就不会再重发 SYN 了，那么 SYN 队列如果空出来了也没有机会建立连接
```



> #### 4、Accept 队列满了，那么接收方会怎么做？

```
默认情况下，接收方会忽略掉第三次握手发送方的 ACK，然后重发 SYN+ACK，重试直到发送方超时，如果这段期间 Accept 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么 Accept 队列如果空出来了也没有机会建立连接
```





## 5、TCP 和 UDP 的区别

```java
1、TCP 是面向连接的，数据传输前需要进行三次握手，做数据传输前的初始化准备；UDP 无连接，想发送数据直接发送即可
2、TCP 基于字节流，数据之间不存在界限，由于在 TCP 头部不存在字段标识报文长度，所以需要在应用层进行处理，解决粘包；UDP 是基于报文的，在 UDP 头部存在字段能够标识报文长度，所以不会发生粘包（实际上 TCP 协议本身没有包的概念，感觉这个粘包的描述有点问题）
3、TCP 可以进行分片，因为它是字节流，没有数据界限，当数据超过 MSS 时可以在 IP 层进行分片；UDP 不能分片，当 IP 报文长度超过 MTU，即 UDP 报文长度超过 MSS，那么 UDP 包将被舍弃
4、TCP 由于是连接，所以是点对点的；UDP 本身不存在连接的概念，那么可以是一对一、一对多
5、TCP 通过序列号和确认号机制、超时重传机制、滑动窗口机制、流量控制机制、拥塞控制机制来保证数据的可靠性传输；UDP 本身并不存在这些机制，它不负责可靠性，因此发生丢包问题也不会进行处理

简单讲就是 TCP 由于需要实现了可靠性传输，所以效率会比 UDP 差很多，同时它的拥塞控制机制是在操作系统内核实现的，无法在应用层进行修改，所以在很多情况下都显得太重，因此在 HTTP 3.0 中才会使用 UDP 来实现。
```

