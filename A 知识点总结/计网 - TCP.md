# 计网 - TCP（传输控制协议）



## TCP 三次握手 / 四次挥手

```
1、TCP 三次握手
第一次握手：发送方初始化一个随机数 seq1 作为序列号，将 SYN 标志位置 1，将报文发送给接收方，处于 SYN_SENT 状态
第二次握手：接收方收到后，初始化一个随机数 seq2 作为序列化，将 ack 设置为 seq1 + 1，将 SYN、ACK 标志位置 1，发送给发送方，处于 SYN_RECV 状态
第三次握手：发送方收到后，返回一个 ACK 报文，seq = seq1+1, ack 设置为 seq2 + 1，发送给接收方，此时处于 ESxxx（建立）状态
接收方收到后，处于 ESxxx（建立）状态

为什么不能是两次握手？
有 3 个原因：
    1）确认双方的发送和接收能力都正常
    2）避免历史连接：比如发送方第一次发送了 SYN，结果由于网络拥堵，发送方再次发送一个 SYN，此时第一个 SYN 到达接收方，接收方回应 SYN + ACK，发送方再回应 ACK，而此时第二次发送的 SYN 也到达了，如果只有两次握手，那么接收方自己并不知道它是历史连接，将它放入到 SYN 队列中，然后回应 ACK，这样就会导致重复连接。而如果是三次握手，在第三次握手中发送方发现这是历史连接，可以发出 RST 中止这个历史连接
    3）确保双方都同步了初始序列号：初始序列号在后续的传输中极其重要，如果只有两次握手，那么接收方并不清楚发送方是否已经同步了自己的初始序列号

为什么不能是四次握手?
    如果是四次握手，那么过程如下：
        第一次握手：发送 SYN
        第二次握手：发送 ACK
        第三次握手：发送 SYN + ACK
        第四次握手：发送 ACK
    跟四次挥手不一样，第二次握手和第三次握手之间不需要什么处理，所以可以直接将第二次握手和第三次握手进行合并

为什么要使用随机初始序列号？
	为了安全性，随机初始序列号是告知对方我们要发送的数据是在这个偏移量上的，比如随机初始序列号为 1000，然后我发送了 1 号字节，那么发送出去的数据的序列号为 1001，减去初始序列号后变成了 1，即发送的数据是整个数据的 1 号字节数据
	如果 TCP 的数据发送都从 0 号开始，那么黑客可以很简单的猜测到 报文的序列号和确认号，从而可以伪造 TCP 报文，比如发送一个 RSET 报文，接收方发现序列号和确认号是对的，所以直接中止了连接。所以使用随机序列号的作用是为了减少黑客攻击成功的几率。因此三次握手同步初始序列号是很重要的
	

2、TCP 四次挥手
第一次挥手：发送方创建一个 TCP 报文（后面都忽略掉这个步骤），将 FIN、ACK 标志位置 1，发送给接收方，此时处于 FIN_WAIT1 状态
第二次挥手：接收方收到，先发送一个 ACK 报文，告知发送方自己收到终止请求，不过此时自己可能有数据还需要处理或者发送，所以此时接收方不会立马发送 FIN 报文，此时处于 CLOSE_WAIT 状态
发送方收到 ACK 报文后，处于 FIN_WAIT2 状态
第三次挥手：接收方处理完数据后，发送 FIN + ACK 报文，此时处于 LAST_ACK 状态
第四次挥手：发送方收到后，发送 ACK 报文，此时处于 TIME_WAIT 状态，这里一般是 2MSL
接受方收到后，进入 CLOSED 状态，发送方 TIME_WAIT 过后，自动进入 CLOSED 状态


为什么需要 TIME_WAIT?
[为什么 TCP 协议有 TIME_WAIT 状态](https://draveness.me/whys-the-design-tcp-time-wait/)
1）为了让被动关闭方能够正常的收到 FIN 的 ACK 然后正常关闭：如果客户端返回 ACK 后就直接进入 CLOSED 状态，如果这个 ACK 在网络中丢失了，那么服务端没有收到，这段时间会一直处于 LAST_ACK 状态，如果这段时间客户端重用了刚刚的四元组发起 SYN 请求，那么服务器会返回一个 RST 终止连接
2）让旧的数据包在网络中消失，不会出现在新的连接上：如果发送完 ACK 直接进入 CLOSED，客户端重用连接，那么在网络中原本属于旧的连接的数据包可能会到达这个新的连接上，导致混乱。

TIME_WAIT 为什么是 2MSL？
1）报文的最大有效时间是 MSL，一旦超过这个时间，那么网络中的报文就无效了，等待 2MSL 必定能使属于此次连接的数据包无效，而不会应用到下一次新的连接中
2）当发送方第四次握手发送 ACK 后，这个报文能够到达接收方的临界时间为 MSL，而接收方在等待了一段时间后，重新发送 FIN + ACK包，这个临界时间也是 MSL，就是当作 ACK 刚刚到达接收方前，接收方又重发了 FIN 这种极端情况，这样的话就又最大需要等待 MSL，如果在这个 2MSL 时间内没有收到 FIN，那么就可以关闭了，因为即使有旧的 FIN + ACK 也已经经过 MSL 无效了

```





## TCP 三次握手可能遭受的攻击

### 1、SYN 攻击

```
在服务端收到客户端第一次握手时，会将该连接存储到 SYN 队列中（半连接队列），攻击者可以伪造 IP 不断发送 SYN 请求，
服务端会响应 SYN+ACK，但是由于这是攻击，所以攻击者不会响应 ACK，这样就会导致服务端的 SYN 队列被挤满，
这样其他正常的 SYN 连接请求就会被丢弃
```

解决方法：

```
1、减少 SYN timeout 的时间（缩短时间，这样霸占在 SYN 队列中的连接在 timeout 时间后会失效）
2、使用 SYN cookie，使用 客户端IP、端口、服务器IP、端口 以及一些安全数值 进行散列运算得到一段信息摘要，这个信息摘要就是 SYN cookie，
	将这个 SYN cookie 代替第二次握手服务端初始化的随机数 作为序列号 seq，然后不将此次连接存储到 SYN 队列，
	当收到第三次握手的报文后，将报文的 ack-1，得到信息摘要1，然后使用相同的数据进行散列运算得到信息摘要2，进行对比，
	一致的话表示没有问题，那么将该连接存储到 Accept 队列中（类似于 CA 证书的校验）

不直接全部采用 SYN cookie 的原因：
计算和验证 SYN cookie 需要 CPU 进行大量计算，如果在高并发的情况下，那么会占用很多的 CPU 资源
```



### 2、Land 攻击

```
攻击者会发起 源IP 和 目的IP 都是 目标主机IP（服务器IP） 的 SYN 报文，这样当服务端收到后会发送一个 SYN+ACK 报文，此时报文的 目的IP 是它自己，攻击者不断发送 SYN 报文会导致服务端不断给自己发送报文，从而导致系统崩溃
```



解决方法：

```
对报文的源IP和目的IP进行校验，如果一致的话可以确定为 Land 攻击
```



## TCP 可靠性实现

```
1、序列号和确认号机制


2、超时重传、快速重传


3、滑动窗口

发送方可以发送多个包，如果接收方多个包都收到了，那么就直接发送最后一个包的 ACK，表示前面的数据都收到了，这就是累计确认；
同时如果同时发送包1、包2、包3，其中包2丢失了，接收方处理好了 包1 和 包3，但是没有包 2，所以它会回应 ACK = 包2，表示没有收到包2，因此发送方会重发包2，接收方收到包2，处理完后，发现包3 也处理了，因此会发送 ACK = 包4
如果接收方收到重复的已处理的包，那么会发送 ACK 告知已经处理

    滑动窗口分为三个指针：字节流中已经发送的并且已经 ACK 的 offset 位置、已经发送但未 ACK 的 offset 位置，剩下的可发送的最后一个字节的 offset 位置
    TCP 发送缓冲区字节流：
    1	2	3	4	5	6	7	8	9	10	11	12	13	14
			👆				👆					👆
			i				j					k
	指针 i 表示该位置以及前面的数据已经发送并且已经收到 ACK，没有它们什么事了，可以直接舍弃
	指针 j 表示 [i + 1, j] 之间的数据是已经发送，但是未收到 ACK 的，需要保留，如果需要的话就进行重传
	指针 k 表示 [j + 1, k] 之间的数据是未发送，但是是可发送的，即表示接收方现在 buffer 缓冲区的可用大小，这些数据可以不用等待前面数据 ACK，可以直接发送
	指针 k 后面的数据表示未发送，并且也不能发送

滑动窗口的大小由 TCP 报文头部的滑动窗口大小字段来控制，16bit，所以最大可发送 65535 字节

4、流量控制（利用滑动窗口实现）
流量控制是针对一个 TCP 连接来说的，通过流量控制来限制发送方的发送数据量
如果没有对发送方的发送数据量进行限制，一股脑的有多少数据就发送多少数据，那么接收方处理不过来，会导致数据丢失
因此，发送方需要根据接收方的处理能力来发送数据，即接收方的 buffer 还能够存储多少数据。

滑动窗口的概念实际上是位于发送方的，表示已经发送了哪些数据，剩下的还可以再发送哪些数据，只不过窗口的大小是通过接收方来决定的

发送方会维护一个变量 receive window，简称 rwnd，它是用来记录接收方的 buffer 还可以存储多少数据
而这个数据实际上是接收方告知发送方的，在每次回复 ACK 的时候，接收方都会把 rwnd 的大小告知发送方，发送方通过这个变量来控制发送的数据量

在发送窗口为 0 的时候，接收方在处理完数据后不会主动告知 rwnd 大小，因此这时候 发送发会不断发送 1B 数据包给接收方，当接收方处理完数据，能够接收到这 1B 数据后，那么就会发送 ACK 同时告知 rwnd 的大小，让发送继续发送数据
	（这里为了避免网络中只有小数据包，即糊涂窗口综合征，所以会默认开启 Negle 算法，同时也会导致粘包、拆包问题）
    
   
5、拥塞控制(利用拥塞窗口实现)
拥塞控制是针对整个网络环境来说的，发送方不是单单维护一个滑动窗口，还需要维护一个拥塞窗口
不是接收方告知发送方 rwnd，那么发送方就直接发送 rwnd 的数据，而是需要根据整个网络环境来说，避免整个网络环境发生拥堵
所以需要通过拥塞窗口来控制发送的速率
也就是说，滑动窗口是接收方用来控制发送方的发送数据量，而拥塞窗口是用来控制发送方的发送速率的，一个是考虑接收方的接收能力，一个是考虑网络环境的拥堵情况


1）慢启动：刚建立 TCP 连接时，不会立马发送大数据，而是会一点一点提高数据量
指定拥塞窗口 cwnd = 1，表示只能发送 1MSS 的数据量
当收到 1 个 ACK 后，cwnd + 1
当收到 2 个 ACK 后，cwnd + 2
当收到 4 个 ACK 后，cwnd + 4
。。。
它发送的数据量是层指数增长的

2）拥塞避免：慢启动可以让发送速率很快到达一个理想的值，但不可能一直指数增长下去，所以设置了一个慢启动阈值 ssthresh
当 cwnd 到达这个阈值时，进入拥塞避免算法
假设 cwnd = 8，那么它只有收到 8 个 ACK 后，cwnd + 1
后续收到 9个 ACK 后，cwnd + 1
即开始线性增长

3、快重传和快恢复
在快重传和快恢复还没有出现时，一旦丢包，出现超时重传，TCP 就认为是网络拥堵，那么就会重新开始慢启动过程，这样的话，就会导致在没有网络拥堵的情况下发送速率也降低了
因此出现了快重传和快恢复

如果在超时时间内收到 3 个重复的 ACK 时，那么不需要等待超时重传，开启快重传算法
如果在超时时间内没有收到 3 个重复 ACK，那么重新进行慢启动算法
				（因为出现重复 3 个 ACK 时丢包的概率比乱序的概率要大得多）
快重传：
	1）重传丢失的数据包
    2）将 cwnd 缩减为一半，再将慢启动阈值设置为 cwnd，即 cwnd = cwnd / 2, ssthresh = cwnd
    3）进入快速恢复算法

快恢复：
    1）将 cwnd = cwnd + 3
    	（为什么 +3？因为它认为已经收到 3 个重复的数据包了，那么表示网络中已经减少了 3个包，可以再放三个包进去）
    2）往后收到重复的 ACK，那么 cwnd +1
    3）如果收到新的 ACK，表示接收方已经收到新的数据包了，将 cwnd 设置为 ssthresh，退出快速恢复算法，由于 cwnd == ssthresh，所以开始拥塞避免算法
```

<img src="https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120313249-1589098511.png" style="zoom:60%;" />









## TCP 综合问题

> #### 1、客户端连续三次 write()，服务端分别可能需要调用多少次 read()

```
理想状态下，不丢包，服务端都能够进行接收处理，那么服务端只需要调用一次 read()
丢包情况：
	1）、丢了一个包，重发这个包，这个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	2）、丢了两个包，重发这两个包，两个包正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取丢包的数据
	3）、丢了两个包，重发这两个包，一个包正常到达，另一个包再次丢失，再次重发，正常到达，那么服务端第一次 read() 读取两个包的数据，第二次 read() 读取第一次重发的数据，第三次 read() 读取第二次重发的数据
```



> #### 2、客户端发送问题

MTU = 1000byte

客户端调用两次 write()，每次写入 600 byte，那么客户端会发送多少次，每次数据为多少？

```
在服务端可处理的情况下，客户端第一次发送的数据为 1000byte，第二次发送的数据为 200byte
```

第一次发送后第二次发送是立刻发送还是会等一会才发送？

```
根据 TCP 参数配置，默认情况下是会等一会才发送的，因为剩下的 200byte 属于小包，TCP 为了避免频繁的小包发送开启了 Nagle 算法，只有等待超时或者包数据到达一定量或者包存在FIN标识符等才会发送处理
如果我们关闭了 Nagle 算法，并且服务端可处理的情况下，包会立马发送
```



> #### 3、SYN 队列满了，那么接收方会怎么做？

```
默认情况下，如果没有开启 SYN cookie，那么接收方会直接丢弃连接，什么都不回复，发送方在没有收到 SYN + ACK 时会继续重发一定的次数，如果重发次数这段期间 SYN 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么发送方就不会再重发 SYN 了，那么 SYN 队列如果空出来了也没有机会建立连接
```



> #### 4、Accept 队列满了，那么接收方会怎么做？

```
默认情况下，接收方会忽略掉第三次握手发送方的 ACK，然后重发 SYN+ACK，重试直到发送方超时，如果这段期间 Accept 队列空出来了，那么会将该连接入队

可以配置接收方回复 RST，但是需要注意的是回复 RST 是让发送方终止连接，那么 Accept 队列如果空出来了也没有机会建立连接
```



> #### 5、糊涂窗口综合征

窗口通告：接收方收到数据后返回 ACK 报文，在 TCP 报文头部有 `窗口大小`字段，该字段用来通告对方自己的TCP接收缓冲区还能接收多少字节数据，以此来控制对方的滑动窗口大小，实现流量控制

发送方滑动窗口大小是发送方可以发送的数据量，当发送方直接将滑动窗口内的数据都发送完成后，对于发送方来说窗口大小变成 0，那么它将不能够再发送数据，直到接收方从接收缓冲区接收数据并返回 ACK 来通告滑动窗口大小



## TCP 知识点整理

问题：

```
TCP 如何处理重复的报文数据？
TCP 如何避免主动关闭方一直处于 FIN_WAIT2 状态？
如何避免半打开的 TCP 连接占用服务器资源？
```



![image.png](https://pic.leetcode-cn.com/1631177972-VUECjW-image.png)

<img src="https://img-blog.csdnimg.cn/20191208122542343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzU0NTcz,size_16,color_FFFFFF,t_70"  width="700"  height = "500" />





<img src="https://pic.leetcode-cn.com/1631199379-oPwUGl-image.png"  width="1200"  height = "300" />





```
TCP 不会去对传输的字节流进行任何的解释处理，TCP 并不知道这个字节流是作为二进制数据还是十六进制数据、按照 ASCII 编码还是根据 Unicode 编码，对字节流的解释全部在应用层去处理，由程序员自己去处理

URG：紧急指针标志位
SYN：请求建立连接
ACK：对前面数据的应答，同时表示期望下一个收到的字节序号
RST：重建连接/中止连接
FIN：数据发送完成，请求关闭连接
PSH：接收方应该尽快将该报文交给应用层

TCP 报文头部的源端口和目的端口是用来寻找发送方和接收方的进程的，而 IP 报文的源IP和目的IP则是用来寻找发送方和接收方的主机

TCP 可以表述为一个缺少选择确认或否认的滑动窗口协议
缺少选择确认是说 TCP 在收到 1-1024 字节的以及 2049-3072 字节的时候，它无法对 2049-3072 字节进行确认，它能做的就是返回一个 ack = 1025 的响应，由于没有确认所以客户端此时并不知道服务端是否收到了 2049-3072 字节
缺少否认是说 TCP 在收到 1-1024 字节后，再收到 1025-2048 字节，但是这段报文的检验和出现错误，那么它不能对这段报文进行否认，不能告知发送方报文出错，它只能将错误的报文进行丢弃处理，并发送 ack = 1025 的响应让发送方重新发送
（检验和：检验 TCP 报文数据是否正确，是否在发送的过程中出现了改动，由发送方计算和存储，由接收方进行验证）

TCP 滑动窗口的大小由 TCP 报文头部的窗口大小字段来控制，16bit，所以最大可发送 65535 字节

当 URG = 1 时，TCP 头部的紧急指针字段才生效，它是一个正的偏移量，表示紧张数据的最后一个字节的序号，序列号表示当前 TCP 报文数据第一个字节的序号，两者构成紧急数据。URG = 1 的数据到达接收方时不进入缓冲区直接交给上一层，因为表示紧急数据，需要加快处理。
当 PSH = 1 时，报文数据要进入缓冲区，但是不需要等缓冲区满就交给上一层，一般是用来告知接收方快点将缓冲区数据读取出去，为后续的数据发送腾出空间

MTU：最大传输单元，这是数据链路层对数据包的大小限制，超过这个限制的数据包会被丢弃，拒绝转发
MSS：最大报文长度，表示发送方每次能够发送的最大数据长度， MSS = MTU-IP报文头部-TCP 报文头部 = MTU-20-20 = MTU-40
MSS 的作用是为了避免在IP层进行分片

半关闭：一方发送完数据后关闭发送能力，但仍想要接收另一方的数据并回复 ACK
1）、发送方发送完数据后调用 close() 会关闭数据发送和接收能力（但不影响接收接收方对 FIN 的 ACK 以及发送方的 FIN 报文），这段期间如果接收方发送数据过来那么发送方会回应 RST 中止连接
2）、发送方发送完数据调用 shutdown()，发送方会关闭发送能力，但仍然存在接收能力，对于接收方调用 close() 前的这段期间发送的数据能够正常回复 ACK 并进行处理
close() 和 shutdown() 都是为了告知接收方数据已经全部发送完成了，而半关闭是为了让主动关闭方还能够接收接收方还没有发送完成的数据

FIN_WAIT2 状态是主动关闭方发送完 FIN 然后收到接收方的 ACK 后进入的状态，如果接收方忘记调用 close()，那么发送方将一直处于 FIN_WAIT2，接收方将一直处于 CLOSE_WAIT，为了避免一直处于 FIN_WAIT2 状态，采用如下设计：
	如果主动关闭方调用 close() 而不是调用 shutdown()，表示它并不需要在 FIN_WAIT2 阶段等待接收方的数据，那么在调用 close() 后开启一个定时器，当定时器超时后还没有收到 FIN 报文，那么发送方直接进入 CLOSED 状态
	（这种设计并不符合 TCP 规范，但是大部分系统都这么设计）
	
TCP 半打开连接：一方已经关闭或者异常掉线，而另一方还不知道。任何一方连接主机掉线都可能导致这种情况，如果不在半打开的连接上进行数据传输，那么仍然处于连接的一方将不会察觉到对方已经掉线，因此会一直保持着连接。
当我们作为客户端去给服务器发送信息，当发送完成后我们直接主机关机，而如果服务器没有再向客户端发送数据，那么它将认为客户端还存活，继续保持着这个连接，这种情况将会导致服务器保持着许多的半打开连接占用系统资源。

TCP 的保活机制 keep-alive： TCP 保活机制是为服务端提供的，它主要是用来解决服务端保持多个 TCP 半打开连接的问题（客户端实际上也能够开启）
服务端会为每个TCP连接维护一个默认为 2小时的定时器，当2小时内没有收到客户端的数据，那么会发送一个心跳包检测客户端是否存活
客户端可能处于以下几种情况：
	1）、客户端正常运行，回复 ACK，服务端收到响应判定客户端存活，那么将定时器重置，重新定时
	2）、客户端异常掉线，不会回复 ACK，服务端超时重发心跳包，重试10次都没有 ACK，判定客户端没有存活，将连接断开
	3）、客户端异常掉线后重新启动，收到心跳包后由于已经不维持该连接，所以回复 RST，服务端收到 RST 中止连接
	4）、客户端存活但不可达，那么跟 2）一样，重试10次后断开连接
TCP 保活心跳包：客户端期望收到的服务端的序列号为 ack，TCP 心跳包则是服务端发送 seq = ack-1 的数据报文，这样客户端收到后发现 seq 对不上，就会响应 ACK 报文，服务端收到 ACK 后以此来探测客户端存活

服务端调用 listen() 进入 LISTEN 状态，当 TCP 三次握手完成后完成 TCP 连接的建立,进入到 Accept 队列，此时应用层实际上还并不知道连接的存在，等到调用 accept() 从中获取到连接后才会知道该连接的存在，而对于客户端来说，三次握手完成后它会认为服务器已经准备好接收数据了，那么此时服务器 TCP 接收到的数据会被放入到缓冲队列中，等到应用层 accept() 获取连接后再进行读取
```



